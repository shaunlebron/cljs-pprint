{:clj-files {"print_table.clj" ["print-table"],
             "dispatch.clj" ["use-method"
                             "reader-macros"
                             "pprint-reader-macro"
                             "pprint-simple-list"
                             "pprint-list"
                             "pprint-vector"
                             "pprint-array"
                             "pprint-map"
                             "pprint-set"
                             "type-map"
                             "map-ref-type"
                             "pprint-ideref"
                             "pprint-pqueue"
                             "pprint-simple-default"
                             "simple-dispatch"
                             "brackets"
                             "pprint-ns-reference"
                             "pprint-ns"
                             "pprint-hold-first"
                             "single-defn"
                             "multi-defn"
                             "pprint-defn"
                             "pprint-binding-form"
                             "pprint-let"
                             "pprint-if"
                             "pprint-cond"
                             "pprint-condp"
                             "*symbol-map*"
                             "pprint-anon-func"
                             "pprint-simple-code-list"
                             "two-forms"
                             "add-core-ns"
                             "*code-table*"
                             "pprint-code-list"
                             "pprint-code-symbol"
                             "code-dispatch"],
             "column_writer.clj" ["*default-page-width*"
                                  "get-field"
                                  "set-field"
                                  "get-column"
                                  "get-line"
                                  "get-max-column"
                                  "set-max-column"
                                  "get-writer"
                                  "c-write-char"
                                  "column-writer"],
             "utilities.clj" ["map-passing-context"
                              "consume"
                              "consume-while"
                              "unzip-map"
                              "tuple-map"
                              "rtrim"
                              "ltrim"
                              "prefix-count"
                              "prerr"
                              "prlabel"
                              "PrettyFlush"],
             "cl_format.clj" ["cl-format"
                              "*format-str*"
                              "format-error"
                              "arg-navigator"
                              "init-navigator"
                              "next-arg"
                              "next-arg-or-nil"
                              "get-format-arg"
                              "absolute-reposition"
                              "relative-reposition"
                              "compiled-directive"
                              "realize-parameter"
                              "realize-parameter-list"
                              "special-radix-markers"
                              "format-simple-number"
                              "format-ascii"
                              "integral?"
                              "remainders"
                              "base-str"
                              "java-base-formats"
                              "opt-base-str"
                              "group-by*"
                              "format-integer"
                              "english-cardinal-units"
                              "english-ordinal-units"
                              "english-cardinal-tens"
                              "english-ordinal-tens"
                              "english-scale-numbers"
                              "format-simple-cardinal"
                              "add-english-scales"
                              "format-cardinal-english"
                              "format-simple-ordinal"
                              "format-ordinal-english"
                              "old-roman-table"
                              "new-roman-table"
                              "format-roman"
                              "format-old-roman"
                              "format-new-roman"
                              "special-chars"
                              "pretty-character"
                              "readable-character"
                              "plain-character"
                              "abort?"
                              "execute-sub-format"
                              "float-parts-base"
                              "float-parts"
                              "inc-s"
                              "round-str"
                              "expand-fixed"
                              "insert-decimal"
                              "get-fixed"
                              "insert-scaled-decimal"
                              "convert-ratio"
                              "fixed-float"
                              "exponential-float"
                              "general-float"
                              "dollar-float"
                              "choice-conditional"
                              "boolean-conditional"
                              "check-arg-conditional"
                              "iterate-sublist"
                              "iterate-list-of-sublists"
                              "iterate-main-list"
                              "iterate-main-sublists"
                              "logical-block-or-justify"
                              "render-clauses"
                              "justify-clauses"
                              "downcase-writer"
                              "upcase-writer"
                              "capitalize-string"
                              "capitalize-word-writer"
                              "init-cap-writer"
                              "modify-case"
                              "get-pretty-writer"
                              "fresh-line"
                              "absolute-tabulation"
                              "relative-tabulation"
                              "format-logical-block"
                              "set-indent"
                              "conditional-newline"
                              "process-directive-table-element"
                              "defdirectives"
                              "param-pattern"
                              "special-params"
                              "extract-param"
                              "extract-params"
                              "translate-param"
                              "flag-defs"
                              "extract-flags"
                              "check-flags"
                              "map-params"
                              "compile-directive"
                              "compile-raw-string"
                              "right-bracket"
                              "separator?"
                              "else-separator?"
                              "process-bracket"
                              "process-clause"
                              "collect-clauses"
                              "process-nesting"
                              "compile-format"
                              "needs-pretty"
                              "execute-format"
                              "cached-compile"
                              "formatter"
                              "formatter-out"],
             "pprint_base.clj" ["*print-pretty*"
                                "*print-pprint-dispatch*"
                                "*print-right-margin*"
                                "*print-miser-width*"
                                "*print-lines*"
                                "*print-circle*"
                                "*print-shared*"
                                "*print-suppress-namespaces*"
                                "*print-radix*"
                                "*print-base*"
                                "*current-level*"
                                "*current-length*"
                                "orig-pr"
                                "pr-with-base"
                                "write-option-table"
                                "binding-map"
                                "table-ize"
                                "pretty-writer?"
                                "make-pretty-writer"
                                "with-pretty-writer"
                                "write-out"
                                "write"
                                "pprint"
                                "pp"
                                "set-pprint-dispatch"
                                "with-pprint-dispatch"
                                "parse-lb-options"
                                "check-enumerated-arg"
                                "level-exceeded"
                                "pprint-logical-block"
                                "pprint-newline"
                                "pprint-indent"
                                "pprint-tab"
                                "pll-mod-body"
                                "print-length-loop"],
             "pretty_writer.clj" ["getf"
                                  "setf"
                                  "deftype"
                                  "logical-block"
                                  "ancestor?"
                                  "section"
                                  "buffer-length"
                                  "buffer-blob"
                                  "nl-t"
                                  "start-block-t"
                                  "end-block-t"
                                  "indent-t"
                                  "pp-newline"
                                  "write-token"
                                  "write-token :start-block-t"
                                  "write-token :end-block-t"
                                  "write-token :indent-t"
                                  "write-token :buffer-blob"
                                  "write-token :nl-t"
                                  "write-tokens"
                                  "tokens-fit?"
                                  "linear-nl?"
                                  "miser-nl?"
                                  "emit-nl?"
                                  "emit-nl? :linear"
                                  "emit-nl? :miser"
                                  "emit-nl? :fill"
                                  "emit-nl? :mandatory"
                                  "get-section"
                                  "get-sub-section"
                                  "update-nl-state"
                                  "emit-nl"
                                  "split-at-newline"
                                  "tok"
                                  "tok :nl-t"
                                  "tok :buffer-blob"
                                  "tok :default"
                                  "toks"
                                  "write-token-string"
                                  "write-line"
                                  "add-to-buffer"
                                  "write-buffered-output"
                                  "write-white-space"
                                  "write-initial-lines"
                                  "p-write-char"
                                  "pretty-writer"
                                  "start-block"
                                  "end-block"
                                  "nl"
                                  "indent"
                                  "get-miser-width"
                                  "set-miser-width"
                                  "set-logical-block-callback"]},
 :cljs-files {"pprint.clj" ["with-pretty-writer"
                            "getf"
                            "setf"
                            "deftype"
                            "parse-lb-options"
                            "pprint-logical-block"
                            "pll-mod-body"
                            "print-length-loop"
                            "process-directive-table-element"
                            "defdirectives"
                            "formatter"
                            "formatter-out"
                            "with-pprint-dispatch"],
              "pprint.cljs" ["*out*"
                             "print"
                             "println"
                             "print-char"
                             "pr"
                             "prn"
                             "float?"
                             "char-code"
                             "map-passing-context"
                             "consume"
                             "consume-while"
                             "unzip-map"
                             "tuple-map"
                             "rtrim"
                             "ltrim"
                             "prefix-count"
                             "IPrettyFlush"
                             "*default-page-width*"
                             "get-field"
                             "set-field"
                             "get-column"
                             "get-line"
                             "get-max-column"
                             "set-max-column"
                             "get-writer"
                             "c-write-char"
                             "column-writer"
                             "logical-block"
                             "ancestor?"
                             "buffer-length"
                             "buffer-blob"
                             "nl-t"
                             "start-block-t"
                             "end-block-t"
                             "indent-t"
                             "pp-newline"
                             "write-token"
                             "write-token :start-block-t"
                             "write-token :end-block-t"
                             "write-token :indent-t"
                             "write-token :buffer-blob"
                             "write-token :nl-t"
                             "write-tokens"
                             "tokens-fit?"
                             "linear-nl?"
                             "miser-nl?"
                             "emit-nl?"
                             "emit-nl? :linear"
                             "emit-nl? :miser"
                             "emit-nl? :fill"
                             "emit-nl? :mandatory"
                             "get-section"
                             "get-sub-section"
                             "update-nl-state"
                             "emit-nl"
                             "split-at-newline"
                             "write-token-string"
                             "write-line"
                             "add-to-buffer"
                             "write-buffered-output"
                             "write-white-space"
                             "write-initial-lines"
                             "p-write-char"
                             "pretty-writer"
                             "start-block"
                             "end-block"
                             "nl"
                             "indent"
                             "get-miser-width"
                             "*print-pretty*"
                             "*print-pprint-dispatch*"
                             "*print-right-margin*"
                             "*print-miser-width*"
                             "*print-lines*"
                             "*print-circle*"
                             "*print-shared*"
                             "*print-suppress-namespaces*"
                             "*print-radix*"
                             "*print-base*"
                             "*current-level*"
                             "*current-length*"
                             "write-option-table"
                             "table-ize"
                             "pretty-writer?"
                             "make-pretty-writer"
                             "write-out"
                             "write"
                             "pprint"
                             "set-pprint-dispatch"
                             "check-enumerated-arg"
                             "level-exceeded"
                             "pprint-newline"
                             "pprint-indent"
                             "pprint-tab"
                             "cl-format"
                             "*format-str*"
                             "format-error"
                             "arg-navigator"
                             "init-navigator"
                             "next-arg"
                             "next-arg-or-nil"
                             "get-format-arg"
                             "absolute-reposition"
                             "relative-reposition"
                             "compiled-directive"
                             "realize-parameter"
                             "realize-parameter-list"
                             "special-radix-markers"
                             "format-simple-number"
                             "format-ascii"
                             "integral?"
                             "remainders"
                             "base-str"
                             "javascript-base-formats"
                             "opt-base-str"
                             "group-by*"
                             "format-integer"
                             "english-cardinal-units"
                             "english-ordinal-units"
                             "english-cardinal-tens"
                             "english-ordinal-tens"
                             "english-scale-numbers"
                             "format-simple-cardinal"
                             "add-english-scales"
                             "format-cardinal-english"
                             "format-simple-ordinal"
                             "format-ordinal-english"
                             "old-roman-table"
                             "new-roman-table"
                             "format-roman"
                             "format-old-roman"
                             "format-new-roman"
                             "special-chars"
                             "pretty-character"
                             "readable-character"
                             "plain-character"
                             "abort?"
                             "execute-sub-format"
                             "float-parts-base"
                             "float-parts"
                             "inc-s"
                             "round-str"
                             "expand-fixed"
                             "insert-decimal"
                             "get-fixed"
                             "insert-scaled-decimal"
                             "convert-ratio"
                             "fixed-float"
                             "exponential-float"
                             "general-float"
                             "dollar-float"
                             "choice-conditional"
                             "boolean-conditional"
                             "check-arg-conditional"
                             "iterate-sublist"
                             "iterate-list-of-sublists"
                             "iterate-main-list"
                             "iterate-main-sublists"
                             "logical-block-or-justify"
                             "render-clauses"
                             "justify-clauses"
                             "downcase-writer"
                             "upcase-writer"
                             "is-letter?"
                             "capitalize-string"
                             "is-whitespace?"
                             "capitalize-word-writer"
                             "init-cap-writer"
                             "modify-case"
                             "get-pretty-writer"
                             "fresh-line"
                             "absolute-tabulation"
                             "relative-tabulation"
                             "format-logical-block"
                             "set-indent"
                             "conditional-newline"
                             "param-pattern"
                             "special-params"
                             "extract-param"
                             "extract-params"
                             "translate-param"
                             "flag-defs"
                             "extract-flags"
                             "check-flags"
                             "map-params"
                             "compile-directive"
                             "compile-raw-string"
                             "right-bracket"
                             "separator?"
                             "else-separator?"
                             "process-bracket"
                             "process-clause"
                             "collect-clauses"
                             "process-nesting"
                             "compile-format"
                             "needs-pretty"
                             "execute-format"
                             "cached-compile"
                             "use-method"
                             "reader-macros"
                             "pprint-reader-macro"
                             "pprint-simple-list"
                             "pprint-list"
                             "pprint-vector"
                             "pprint-array"
                             "pprint-map"
                             "pprint-simple-default"
                             "pprint-set"
                             "type-map"
                             "map-ref-type"
                             "pprint-ideref"
                             "pprint-pqueue"
                             "type-dispatcher"
                             "simple-dispatch"
                             "brackets"
                             "pprint-ns-reference"
                             "pprint-ns"
                             "pprint-hold-first"
                             "single-defn"
                             "multi-defn"
                             "pprint-defn"
                             "pprint-binding-form"
                             "pprint-let"
                             "pprint-if"
                             "pprint-cond"
                             "pprint-condp"
                             "*symbol-map*"
                             "pprint-anon-func"
                             "pprint-simple-code-list"
                             "two-forms"
                             "add-core-ns"
                             "*code-table*"
                             "pprint-code-list"
                             "pprint-code-symbol"
                             "code-dispatch"
                             "add-padding"
                             "print-table"]},
 :clj {"nl" {:type "defn-",
             :key "nl",
             :lines [468 472],
             :filename "pretty_writer.clj",
             :source "(defn- nl [^Writer this type]\n  (dosync \n   (setf :mode :buffering)\n   (let [pos (getf :pos)]\n     (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos)))))"},
       "pprint-defn" {:type "defn-",
                      :key "pprint-defn",
                      :lines [268 287],
                      :filename "dispatch.clj",
                      :source "(defn- pprint-defn [alis]\n  (if (next alis) \n    (let [[defn-sym defn-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map stuff] (if (map? (first stuff))\n                             [(first stuff) (next stuff)]\n                             [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") defn-sym defn-name)\n        (if doc-str\n          ((formatter-out \" ~_~w\") doc-str))\n        (if attr-map\n          ((formatter-out \" ~_~w\") attr-map))\n        ;; Note: the multi-defn case will work OK for malformed defns too\n        (cond\n         (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n         :else (multi-defn stuff (or doc-str attr-map)))))\n    (pprint-simple-code-list alis)))"},
       "pprint" {:type "defn",
                 :key "pprint",
                 :lines [241 252],
                 :filename "pprint_base.clj",
                 :source "(defn pprint \n  \"Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.\"\n  {:added \"1.2\"}\n  ([object] (pprint object *out*)) \n  ([object writer]\n     (with-pretty-writer writer\n       (binding [*print-pretty* true]\n         (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) \n           (write-out object)))\n       (if (not (= 0 (get-column *out*)))\n         (prn)))))"},
       "parse-lb-options" {:type "defn-",
                           :key "parse-lb-options",
                           :lines [285 290],
                           :filename "pprint_base.clj",
                           :source "(defn- parse-lb-options [opts body]\n  (loop [body body\n         acc []]\n    (if (opts (first body))\n      (recur (drop 2 body) (concat acc (take 2 body)))\n      [(apply hash-map acc) body])))"},
       "conditional-newline" {:type "defn-",
                              :key "conditional-newline",
                              :lines [1307 1312],
                              :filename "cl_format.clj",
                              :source "(defn- conditional-newline [params navigator offsets]\n  (let [kind (if (:colon params) \n               (if (:at params) :mandatory :fill)\n               (if (:at params) :miser :linear))]\n    (pprint-newline kind)\n    navigator))"},
       "*print-lines*" {:type "def",
                        :key "*print-lines*",
                        :lines [55 58],
                        :filename "pprint_base.clj",
                        :source "(def ^:dynamic\n ^{:private true,\n   :doc \"Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)\"}\n *print-lines* nil)"},
       "pprint-cond" {:type "defn-",
                      :key "pprint-cond",
                      :lines [325 343],
                      :filename "dispatch.clj",
                      :source "(defn- pprint-cond [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (write-out (first alis))\n    (when (next alis)\n      (.write ^java.io.Writer *out* \" \")\n      (pprint-newline :linear)\n     (print-length-loop [alis (next alis)]\n       (when alis\n         (pprint-logical-block alis\n          (write-out (first alis))\n          (when (next alis)\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second alis))))\n         (when (next (rest alis))\n           (.write ^java.io.Writer *out* \" \")\n           (pprint-newline :linear)\n           (recur (next (rest alis)))))))))"},
       "english-ordinal-units" {:type "def",
                                :key "english-ordinal-units",
                                :lines [295 299],
                                :filename "cl_format.clj",
                                :source "(def ^{:private true}\n     english-ordinal-units \n     [\"zeroth\" \"first\" \"second\" \"third\" \"fourth\" \"fifth\" \"sixth\" \"seventh\" \"eighth\" \"ninth\"\n      \"tenth\" \"eleventh\" \"twelfth\" \"thirteenth\" \"fourteenth\"\n      \"fifteenth\" \"sixteenth\" \"seventeenth\" \"eighteenth\" \"nineteenth\"])"},
       "*print-right-margin*" {:type "def",
                               :key "*print-right-margin*",
                               :lines [40 45],
                               :filename "pprint_base.clj",
                               :source "(def ^:dynamic\n ^{:doc \"Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.\",\n   :added \"1.2\"}\n *print-right-margin* 72)"},
       "capitalize-word-writer" {:type "defn-",
                                 :key "capitalize-word-writer",
                                 :lines [1132 1158],
                                 :filename "cl_format.clj",
                                 :source "(defn- capitalize-word-writer\n  \"Returns a proxy that wraps writer, capitalizing all words\"\n  [^java.io.Writer writer]\n  (let [last-was-whitespace? (ref true)] \n    (proxy [java.io.Writer] []\n      (close [] (.close writer))\n      (flush [] (.flush writer))\n      (write \n       ([^chars cbuf ^Integer off ^Integer len] \n          (.write writer cbuf off len))\n       ([x]\n          (condp = (class x)\n            String \n            (let [s ^String x]\n              (.write writer \n                      ^String (capitalize-string (.toLowerCase s) @last-was-whitespace?))\n              (when (pos? (.length s))\n                (dosync \n                 (ref-set last-was-whitespace? \n                          (Character/isWhitespace \n                           ^Character (nth s (dec (count s))))))))\n\n            Integer\n            (let [c (char x)]\n              (let [mod-c (if @last-was-whitespace? (Character/toUpperCase (char x)) c)]\n                (.write writer (int mod-c))\n                (dosync (ref-set last-was-whitespace? (Character/isWhitespace (char x))))))))))))"},
       "defdirectives" {:type "defmacro",
                        :key "defdirectives",
                        :lines [1328 1332],
                        :filename "cl_format.clj",
                        :source "(defmacro ^{:private true}\n  defdirectives \n  [ & directives ]\n  `(def ^{:private true}\n        directive-table (hash-map ~@(mapcat process-directive-table-element directives))))"},
       "consume" {:type "defn-",
                  :key "consume",
                  :lines [37 43],
                  :filename "utilities.clj",
                  :source "(defn- consume [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result new-context] (apply func [context])]\n      (if (not result)\n        [acc new-context]\n      (recur new-context (conj acc result))))))"},
       "add-to-buffer" {:type "defn-",
                        :key "add-to-buffer",
                        :lines [300 305],
                        :filename "pretty_writer.clj",
                        :source "(defn- add-to-buffer [^Writer this token]\n;  (prlabel a2b token)\n  (dosync\n   (setf :buffer (conj (getf :buffer) token))\n   (if (not (tokens-fit? this (getf :buffer)))\n     (write-line this))))"},
       "nl-t" {:type "deftype",
               :key "nl-t",
               :lines [87 87],
               :filename "pretty_writer.clj",
               :source "(deftype nl-t :type :logical-block :start-pos :end-pos)"},
       "single-defn" {:type "defn-",
                      :key "single-defn",
                      :lines [253 259],
                      :filename "dispatch.clj",
                      :source "(defn- single-defn [alis has-doc-str?]\n  (if (seq alis)\n    (do\n      (if has-doc-str?\n        ((formatter-out \" ~_\"))\n        ((formatter-out \" ~@_\")))\n      ((formatter-out \"~{~w~^ ~_~}\") alis))))"},
       "param-pattern" {:type "def",
                        :key "param-pattern",
                        :lines [1619 1620],
                        :filename "cl_format.clj",
                        :source "(def ^{:private true}\n     param-pattern #\"^([vV]|#|('.)|([+-]?\\d+)|(?=,))\")"},
       "start-block-t" {:type "deftype",
                        :key "start-block-t",
                        :lines [89 89],
                        :filename "pretty_writer.clj",
                        :source "(deftype start-block-t :logical-block :start-pos :end-pos)"},
       "set-field" {:type "defn-",
                    :key "set-field",
                    :lines [28 29],
                    :filename "column_writer.clj",
                    :source "(defn- set-field [^Writer this sym new-val] \n  (alter @this assoc sym new-val))"},
       "write-token :buffer-blob" {:type "defmethod",
                                   :key "write-token :buffer-blob",
                                   :lines [127 128],
                                   :filename "pretty_writer.clj",
                                   :source "(defmethod write-token :buffer-blob [^Writer this token]\n  (.write (getf :base) ^String (:data token)))"},
       "format-ascii" {:type "defn-",
                       :key "format-ascii",
                       :lines [182 198],
                       :filename "cl_format.clj",
                       :source "(defn- format-ascii [print-func params arg-navigator offsets]\n  (let [ [arg arg-navigator] (next-arg arg-navigator) \n         ^String base-output (or (format-simple-number arg) (print-func arg))\n         base-width (.length base-output)\n         min-width (+ base-width (:minpad params))\n         width (if (>= min-width (:mincol params)) \n                 min-width\n                 (+ min-width \n                    (* (+ (quot (- (:mincol params) min-width 1) \n                                (:colinc params) )\n                          1)\n                       (:colinc params))))\n         chars (apply str (repeat (- width base-width) (:padchar params)))]\n    (if (:at params)\n      (print (str chars base-output))\n      (print (str base-output chars)))\n    arg-navigator))"},
       "map-params" {:type "defn-",
                     :key "map-params",
                     :lines [1685 1713],
                     :filename "cl_format.clj",
                     :source "(defn- map-params\n  \"Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.\"\n  [def params flags offset]\n  (check-flags def flags)\n  (if (> (count params) (count (:params def)))\n    (format-error \n     (cl-format \n      nil \n      \"Too many parameters for directive \\\"~C\\\": ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed\"\n      (:directive def) (count params) (count (:params def)))\n     (second (first params))))\n  (doall\n   (map #(let [val (first %1)]\n           (if (not (or (nil? val) (contains? special-params val) \n                        (instance? (second (second %2)) val)))\n             (format-error (str \"Parameter \" (name (first %2))\n                                \" has bad type in directive \\\"\" (:directive def) \"\\\": \"\n                                (class val))\n                           (second %1))) )\n        params (:params def)))\n     \n  (merge                                ; create the result map\n   (into (array-map) ; start with the default values, make sure the order is right\n         (reverse (for [[name [default]] (:params def)] [name [default offset]])))\n   (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils\n   flags))"},
       "emit-nl? :miser" {:type "defmethod",
                          :key "emit-nl? :miser",
                          :lines [184 186],
                          :filename "pretty_writer.clj",
                          :source "(defmethod emit-nl? :miser [newl this section _]\n  (let [lb (:logical-block newl)]\n    (miser-nl? this lb section)))"},
       "choice-conditional" {:type "defn-",
                             :key "choice-conditional",
                             :lines [843 852],
                             :filename "cl_format.clj",
                             :source "(defn- choice-conditional [params arg-navigator offsets]\n  (let [arg (:selector params)\n        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))\n        clauses (:clauses params)\n        clause (if (or (neg? arg) (>= arg (count clauses)))\n                 (first (:else params))\n                 (nth clauses arg))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))"},
       "*print-suppress-namespaces*" {:type "def",
                                      :key "*print-suppress-namespaces*",
                                      :lines [72 76],
                                      :filename "pprint_base.clj",
                                      :source "(def ^:dynamic\n ^{:doc \"Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions\"\n   :added \"1.2\"}\n *print-suppress-namespaces* nil)"},
       "tuple-map" {:type "defn-",
                    :key "tuple-map",
                    :lines [60 62],
                    :filename "utilities.clj",
                    :source "(defn- tuple-map [m v1]\n  \"For all the values, v, in the map, replace them with [v v1]\"\n  (into {} (for [[k v] m] [k [v v1]])))"},
       "next-arg" {:type "defn-",
                   :key "next-arg",
                   :lines [90 94],
                   :filename "cl_format.clj",
                   :source "(defn- next-arg [ navigator ]\n  (let [ rst (:rest navigator) ]\n    (if rst\n      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]\n     (throw (new Exception  \"Not enough arguments for format definition\")))))"},
       "pprint-ns" {:type "defn-",
                    :key "pprint-ns",
                    :lines [215 239],
                    :filename "dispatch.clj",
                    :source "(defn- pprint-ns\n  \"The pretty print dispatch chunk for the ns macro\"\n  [alis]\n  (if (next alis) \n    (let [[ns-sym ns-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map references] (if (map? (first stuff))\n                                  [(first stuff) (next stuff)]\n                                  [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") ns-sym ns-name)\n        (when (or doc-str attr-map (seq references))\n          ((formatter-out \"~@:_\")))\n        (when doc-str\n          (cl-format true \"\\\"~a\\\"~:[~;~:@_~]\" doc-str (or attr-map (seq references))))\n        (when attr-map\n          ((formatter-out \"~w~:[~;~:@_~]\") attr-map (seq references)))\n        (loop [references references]\n          (pprint-ns-reference (first references))\n          (when-let [references (next references)]\n            (pprint-newline :linear)\n            (recur references)))))\n    (write-out alis)))"},
       "execute-sub-format" {:type "defn-",
                             :key "execute-sub-format",
                             :lines [524 535],
                             :filename "cl_format.clj",
                             :source "(defn- execute-sub-format [format args base-args]\n  (second\n   (map-passing-context \n    (fn [element context]\n      (if (abort? context)\n        [nil context] ; just keep passing it along\n        (let [[params args] (realize-parameter-list (:params element) context)\n              [params offsets] (unzip-map params)\n              params (assoc params :base-args base-args)]\n          [nil (apply (:func element) [params args offsets])])))\n    args\n    format)))"},
       "get-miser-width" {:type "defn-",
                          :key "get-miser-width",
                          :lines [487 488],
                          :filename "pretty_writer.clj",
                          :source "(defn- get-miser-width [^Writer this]\n  (getf :miser-width))"},
       "with-pprint-dispatch" {:type "defmacro",
                               :key "with-pprint-dispatch",
                               :lines [274 279],
                               :filename "pprint_base.clj",
                               :source "(defmacro with-pprint-dispatch \n  \"Execute body with the pretty print dispatch function bound to function.\"\n  {:added \"1.2\"}\n  [function & body]\n  `(binding [*print-pprint-dispatch* ~function]\n     ~@body))"},
       "setf" {:type "defmacro",
               :key "setf",
               :lines [43 46],
               :filename "pretty_writer.clj",
               :source "(defmacro ^{:private true} \n  setf [sym new-val] \n  \"Set the value of the field SYM to NEW-VAL\"\n  `(alter @~'this assoc ~sym ~new-val))"},
       "map-passing-context" {:type "defn-",
                              :key "map-passing-context",
                              :lines [26 35],
                              :filename "utilities.clj",
                              :source "(defn- map-passing-context [func initial-context lis]\n  (loop [context initial-context\n         lis lis\n         acc []]\n    (if (empty? lis)\n      [acc context]\n    (let [this (first lis)\n          remainder (next lis)\n          [result new-context] (apply func [this context])]\n      (recur new-context remainder (conj acc result))))))"},
       "*symbol-map*" {:type "def",
                       :key "*symbol-map*",
                       :lines [365 365],
                       :filename "dispatch.clj",
                       :source "(def ^:dynamic ^{:private true} *symbol-map* {})"},
       "general-float" {:type "defn-",
                        :key "general-float",
                        :lines [794 813],
                        :filename "cl_format.clj",
                        :source "(defn- general-float [params navigator offsets]\n  (let [[arg _] (next-arg navigator)\n        arg (convert-ratio arg)\n        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))\n        w (:w params)\n        d (:d params)\n        e (:e params)\n        n (if (= arg 0.0) 0 (inc exp))\n        ee (if e (+ e 2) 4)\n        ww (if w (- w ee))\n        d (if d d (max (count mantissa) (min n 7)))\n        dd (- d n)]\n    (if (<= 0 dd d)\n      (let [navigator (fixed-float {:w ww, :d dd, :k 0, \n                                    :overflowchar (:overflowchar params),\n                                    :padchar (:padchar params), :at (:at params)} \n                                   navigator offsets)]\n        (print (apply str (repeat ee \\space)))\n        navigator)\n      (exponential-float params navigator offsets))))"},
       "process-nesting" {:type "defn-",
                          :key "process-nesting",
                          :lines [1829 1842],
                          :filename "cl_format.clj",
                          :source "(defn- process-nesting\n  \"Take a linearly compiled format and process the bracket directives to give it \n   the appropriate tree structure\"\n  [format]\n  (first\n   (consume \n    (fn [remainder]\n      (let [this (first remainder)\n            remainder (next remainder)\n            bracket (:bracket-info (:def this))]\n        (if (:right bracket)\n          (process-bracket this remainder)\n          [this remainder])))\n    format)))"},
       "level-exceeded" {:type "defn-",
                         :key "level-exceeded",
                         :lines [299 300],
                         :filename "pprint_base.clj",
                         :source "(defn- level-exceeded []\n  (and *print-level* (>= *current-level* *print-level*)))"},
       "execute-format" {:type "defn-",
                         :key "execute-format",
                         :lines [1878 1909],
                         :filename "cl_format.clj",
                         :source "(defn- execute-format \n  \"Executes the format with the arguments.\"\n  {:skip-wiki true}\n  ([stream format args]\n     (let [^java.io.Writer real-stream (cond \n                                         (not stream) (java.io.StringWriter.)\n                                         (true? stream) *out*\n                                         :else stream)\n           ^java.io.Writer wrapped-stream (if (and (needs-pretty format) \n                                                    (not (pretty-writer? real-stream)))\n                                             (get-pretty-writer real-stream)\n                                             real-stream)]\n       (binding [*out* wrapped-stream]\n         (try\n          (execute-format format args)\n          (finally\n           (if-not (identical? real-stream wrapped-stream)\n             (.flush wrapped-stream))))\n         (if (not stream) (.toString real-stream)))))\n  ([format args]\n     (map-passing-context \n      (fn [element context]\n        (if (abort? context)\n          [nil context]\n          (let [[params args] (realize-parameter-list \n                               (:params element) context)\n                [params offsets] (unzip-map params)\n                params (assoc params :base-args args)]\n            [nil (apply (:func element) [params args offsets])])))\n      args\n      format)\n     nil))"},
       "boolean-conditional" {:type "defn-",
                              :key "boolean-conditional",
                              :lines [855 863],
                              :filename "cl_format.clj",
                              :source "(defn- boolean-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg\n                 (second clauses)\n                 (first clauses))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))"},
       "pprint-if" {:type "def",
                    :key "pprint-if",
                    :lines [323 323],
                    :filename "dispatch.clj",
                    :source "(def ^{:private true} pprint-if (formatter-out \"~:<~1I~w~^ ~@_~w~@{ ~_~w~}~:>\"))"},
       "get-pretty-writer" {:type "defn",
                            :key "get-pretty-writer",
                            :lines [1203 1239],
                            :filename "cl_format.clj",
                            :source "(defn get-pretty-writer \n  \"Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's \nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be \npreserved across calls, you will want to wrap them with this. \n\nFor example, when you want to generate column-aware output with multiple calls to cl-format, \ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1    \n       2      4       8    \n       3      9      27    \n       4     16      64    \n       5     25     125    \n       6     36     216    \n       7     49     343    \n       8     64     512    \n       9     81     729    \n      10    100    1000\"\n  {:added \"1.2\"}\n  [writer]\n  (if (pretty-writer? writer) \n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))"},
       "absolute-reposition" {:type "defn-",
                              :key "absolute-reposition",
                              :lines [112 115],
                              :filename "cl_format.clj",
                              :source "(defn- absolute-reposition [navigator position]\n  (if (>= position (:pos navigator))\n    (relative-reposition navigator (- (:pos navigator) position))\n    (struct arg-navigator (:seq navigator) (drop position (:seq navigator)) position)))"},
       "*print-shared*" {:type "def",
                         :key "*print-shared*",
                         :lines [67 70],
                         :filename "pprint_base.clj",
                         :source "(def ^:dynamic\n ^{:private true,\n   :doc \"Mark repeated structures rather than repeat them (N.B. This is not yet used)\"}\n *print-shared* nil)"},
       "write-option-table" {:type "def",
                             :key "write-option-table",
                             :lines [118 134],
                             :filename "pprint_base.clj",
                             :source "(def ^{:private true} write-option-table\n     {;:array            *print-array*\n      :base             'clojure.pprint/*print-base*,\n      ;;:case             *print-case*,\n      :circle           'clojure.pprint/*print-circle*,\n      ;;:escape           *print-escape*,\n      ;;:gensym           *print-gensym*,\n      :length           'clojure.core/*print-length*,\n      :level            'clojure.core/*print-level*,\n      :lines            'clojure.pprint/*print-lines*,\n      :miser-width      'clojure.pprint/*print-miser-width*,\n      :dispatch         'clojure.pprint/*print-pprint-dispatch*,\n      :pretty           'clojure.pprint/*print-pretty*,\n      :radix            'clojure.pprint/*print-radix*,\n      :readably         'clojure.core/*print-readably*,\n      :right-margin     'clojure.pprint/*print-right-margin*,\n      :suppress-namespaces 'clojure.pprint/*print-suppress-namespaces*})"},
       "pp-newline" {:type "def",
                     :key "pp-newline",
                     :lines [99 99],
                     :filename "pretty_writer.clj",
                     :source "(def ^:private pp-newline (memoize #(System/getProperty \"line.separator\")))"},
       "compile-format" {:type "defn-",
                         :key "compile-format",
                         :lines [1844 1863],
                         :filename "cl_format.clj",
                         :source "(defn- compile-format \n  \"Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved \nperformance when you're using the same format string repeatedly\"\n  [ format-str ]\n;  (prlabel compiling format-str)\n  (binding [*format-str* format-str]\n    (process-nesting\n     (first \n      (consume \n       (fn [[^String s offset]]\n         (if (empty? s)\n           [nil s]\n           (let [tilde (.indexOf s (int \\~))]\n             (cond\n              (neg? tilde) [(compile-raw-string s offset) [\"\" (+ offset (.length s))]]\n              (zero? tilde)  (compile-directive (subs s 1) (inc offset))\n              true \n              [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))\n       [format-str 0])))))"},
       "PrettyFlush" {:type "definterface",
                      :key "PrettyFlush",
                      :lines [106 107],
                      :filename "utilities.clj",
                      :source "(definterface PrettyFlush\n  (^void ppflush []))"},
       "realize-parameter-list" {:type "defn-",
                                 :key "realize-parameter-list",
                                 :lines [150 153],
                                 :filename "cl_format.clj",
                                 :source "(defn- realize-parameter-list [parameter-map navigator]\n  (let [[pairs new-navigator] \n        (map-passing-context realize-parameter navigator parameter-map)]\n    [(into {} pairs) new-navigator]))"},
       "write-white-space" {:type "defn-",
                            :key "write-white-space",
                            :lines [315 320],
                            :filename "pretty_writer.clj",
                            :source "(defn- write-white-space [^Writer this]\n  (when-let [^String tws (getf :trailing-white-space)]\n    ; (prlabel wws (str \"*\" tws \"*\"))\n    (.write (getf :base) tws)\n    (dosync\n     (setf :trailing-white-space nil))))"},
       "tok" {:type "defmulti",
              :key "tok",
              :lines [245 245],
              :filename "pretty_writer.clj",
              :source "(defmulti ^{:private true} tok :type-tag)"},
       "dollar-float" {:type "defn-",
                       :key "dollar-float",
                       :lines [817 833],
                       :filename "cl_format.clj",
                       :source "(defn- dollar-float [params navigator offsets]\n  (let [[^Double arg navigator] (next-arg navigator)\n        [mantissa exp] (float-parts (Math/abs arg))\n        d (:d params) ; digits after the decimal\n        n (:n params) ; minimum digits before the decimal\n        w (:w params) ; minimum field width\n        add-sign (or (:at params) (neg? arg))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)\n        ^String fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr (int \\.))) \\0)) fixed-repr)\n        full-len (+ (count full-repr) (if add-sign 1 0))]\n    (print (str\n            (if (and (:colon params) add-sign) (if (neg? arg) \\- \\+))\n            (apply str (repeat (- w full-len) (:padchar params)))\n            (if (and (not (:colon params)) add-sign) (if (neg? arg) \\- \\+))\n            full-repr))\n    navigator))"},
       "get-field" {:type "defn-",
                    :key "get-field",
                    :lines [25 26],
                    :filename "column_writer.clj",
                    :source "(defn- get-field [^Writer this sym]\n  (sym @@this))"},
       "emit-nl? :linear" {:type "defmethod",
                           :key "emit-nl? :linear",
                           :lines [180 182],
                           :filename "pretty_writer.clj",
                           :source "(defmethod emit-nl? :linear [newl this section _]\n  (let [lb (:logical-block newl)]\n    (linear-nl? this lb section)))"},
       "format-integer" {:type "defn-",
                         :key "format-integer",
                         :lines [259 283],
                         :filename "cl_format.clj",
                         :source "(defn- format-integer [base params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)]\n    (if (integral? arg)\n      (let [neg (neg? arg)\n            pos-arg (if neg (- arg) arg)\n            raw-str (opt-base-str base pos-arg)\n            group-str (if (:colon params)\n                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))\n                              commas (repeat (count groups) (:commachar params))]\n                          (apply str (next (interleave commas groups))))\n                        raw-str)\n            ^String signed-str (cond\n                                  neg (str \"-\" group-str)\n                                  (:at params) (str \"+\" group-str)\n                                  true group-str)\n            padded-str (if (< (.length signed-str) (:mincol params))\n                         (str (apply str (repeat (- (:mincol params) (.length signed-str)) \n                                                 (:padchar params)))\n                              signed-str)\n                         signed-str)]\n        (print padded-str))\n      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0 \n                               :padchar (:padchar params) :at true} \n                    (init-navigator [arg]) nil))\n    arg-navigator))"},
       "relative-reposition" {:type "defn-",
                              :key "relative-reposition",
                              :lines [117 121],
                              :filename "cl_format.clj",
                              :source "(defn- relative-reposition [navigator position]\n  (let [newpos (+ (:pos navigator) position)]\n    (if (neg? position)\n      (absolute-reposition navigator newpos)\n      (struct arg-navigator (:seq navigator) (drop position (:rest navigator)) newpos))))"},
       "render-clauses" {:type "defn-",
                         :key "render-clauses",
                         :lines [1002 1014],
                         :filename "cl_format.clj",
                         :source "(defn- render-clauses [clauses navigator base-navigator]\n  (loop [clauses clauses\n         acc []\n         navigator navigator]\n    (if (empty? clauses)\n      [acc navigator]\n      (let [clause (first clauses)\n            [iter-result result-str] (binding [*out* (java.io.StringWriter.)]\n                                       [(execute-sub-format clause navigator base-navigator) \n                                        (.toString *out*)])]\n        (if (= :up-arrow (first iter-result))\n          [acc (second iter-result)]\n          (recur (next clauses) (conj acc result-str) iter-result))))))"},
       "*code-table*" {:type "def",
                       :key "*code-table*",
                       :lines [418 433],
                       :filename "dispatch.clj",
                       :source "(def ^:dynamic ^{:private true} *code-table*\n     (two-forms\n      (add-core-ns\n       {'def pprint-hold-first, 'defonce pprint-hold-first, \n\t'defn pprint-defn, 'defn- pprint-defn, 'defmacro pprint-defn, 'fn pprint-defn,\n        'let pprint-let, 'loop pprint-let, 'binding pprint-let,\n        'with-local-vars pprint-let, 'with-open pprint-let, 'when-let pprint-let,\n\t'if-let pprint-let, 'doseq pprint-let, 'dotimes pprint-let,\n\t'when-first pprint-let,\n        'if pprint-if, 'if-not pprint-if, 'when pprint-if, 'when-not pprint-if,\n        'cond pprint-cond, 'condp pprint-condp,\n        'fn* pprint-anon-func,\n        '. pprint-hold-first, '.. pprint-hold-first, '-> pprint-hold-first,\n        'locking pprint-hold-first, 'struct pprint-hold-first,\n        'struct-map pprint-hold-first, 'ns pprint-ns \n        })))"},
       "remainders" {:type "defn-",
                     :key "remainders",
                     :lines [216 224],
                     :filename "cl_format.clj",
                     :source "(defn- remainders\n  \"Return the list of remainders (essentially the 'digits') of val in the given base\"\n  [base val]\n  (reverse \n   (first \n    (consume #(if (pos? %) \n                [(rem % base) (quot % base)] \n                [nil nil]) \n             val))))"},
       "init-navigator" {:type "defn-",
                         :key "init-navigator",
                         :lines [82 87],
                         :filename "cl_format.clj",
                         :source "(defn- init-navigator \n  \"Create a new arg-navigator from the sequence with the position set to 0\"\n  {:skip-wiki true}\n  [s]\n  (let [s (seq s)]\n    (struct arg-navigator s s 0)))"},
       "logical-block-or-justify" {:type "defn-",
                                   :key "logical-block-or-justify",
                                   :lines [993 996],
                                   :filename "cl_format.clj",
                                   :source "(defn- logical-block-or-justify [params navigator offsets]\n  (if (:colon (:right-params params))\n    (format-logical-block params navigator offsets)\n    (justify-clauses params navigator offsets)))"},
       "group-by*" {:type "defn-",
                    :key "group-by*",
                    :lines [254 257],
                    :filename "cl_format.clj",
                    :source "(defn- group-by* [unit lis]\n  (reverse\n   (first\n    (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))"},
       "insert-scaled-decimal" {:type "defn-",
                                :key "insert-scaled-decimal",
                                :lines [648 653],
                                :filename "cl_format.clj",
                                :source "(defn- insert-scaled-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m k]\n  (if (neg? k)\n    (str \".\" m)\n    (str (subs m 0 k) \".\" (subs m k))))"},
       "type-map" {:type "def",
                   :key "type-map",
                   :lines [111 113],
                   :filename "dispatch.clj",
                   :source "(def ^{:private true} \n     type-map {\"core$future_call\" \"Future\",\n               \"core$promise\" \"Promise\"})"},
       "write-tokens" {:type "defn-",
                       :key "write-tokens",
                       :lines [141 151],
                       :filename "pretty_writer.clj",
                       :source "(defn- write-tokens [^Writer this tokens force-trailing-whitespace]\n  (doseq [token tokens]\n    (if-not (= (:type-tag token) :nl-t)\n      (if-let [^String tws (getf :trailing-white-space)]\n\t(.write (getf :base) tws)))\n    (write-token this token)\n    (setf :trailing-white-space (:trailing-white-space token)))\n  (let [^String tws (getf :trailing-white-space)] \n    (when (and force-trailing-whitespace tws)\n      (.write (getf :base) tws)\n      (setf :trailing-white-space nil))))"},
       "iterate-main-list" {:type "defn-",
                            :key "iterate-main-list",
                            :lines [934 954],
                            :filename "cl_format.clj",
                            :source "(defn- iterate-main-list [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator\n           last-pos (num -1)]\n      (if (and (not max-count) (= (:pos navigator) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (RuntimeException. \"%@{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause navigator (:base-args params))] \n          (if (= :up-arrow (first iter-result))\n            (second iter-result)\n            (recur \n             (inc count) iter-result (:pos navigator))))))))"},
       "process-bracket" {:type "defn-",
                          :key "process-bracket",
                          :lines [1747 1754],
                          :filename "cl_format.clj",
                          :source "(defn- process-bracket [this remainder]\n  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))\n                                           (:offset this) remainder)]\n    [(struct compiled-directive \n             (:func this) (:def this) \n             (merge (:params this) (tuple-map subex (:offset this)))\n             (:offset this))\n     remainder]))"},
       "pprint-let" {:type "defn-",
                     :key "pprint-let",
                     :lines [308 316],
                     :filename "dispatch.clj",
                     :source "(defn- pprint-let [alis]\n  (let [base-sym (first alis)]\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (if (and (next alis) (vector? (second alis)))\n        (do\n          ((formatter-out \"~w ~1I~@_\") base-sym)\n          (pprint-binding-form (second alis))\n          ((formatter-out \" ~_~{~w~^ ~_~}\") (next (rest alis))))\n        (pprint-simple-code-list alis)))))"},
       "pprint-condp" {:type "defn-",
                       :key "pprint-condp",
                       :lines [345 362],
                       :filename "dispatch.clj",
                       :source "(defn- pprint-condp [alis]\n  (if (> (count alis) 3) \n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (pprint-indent :block 1)\n      (apply (formatter-out \"~w ~@_~w ~@_~w ~_\") alis)\n      (print-length-loop [alis (seq (drop 3 alis))]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (.write ^java.io.Writer *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))\n    (pprint-simple-code-list alis)))"},
       "opt-base-str" {:type "defn-",
                       :key "opt-base-str",
                       :lines [245 252],
                       :filename "cl_format.clj",
                       :source "(defn- opt-base-str\n  \"Return val as a string in the given base, using clojure.core/format if supported\nfor improved performance\"\n  [base val]\n  (let [format-str (get java-base-formats base)]\n    (if (and format-str (integer? val) (not (instance? clojure.lang.BigInt val)))\n      (clojure.core/format format-str val)\n      (base-str base val))))"},
       "relative-tabulation" {:type "defn-",
                              :key "relative-tabulation",
                              :lines [1266 1273],
                              :filename "cl_format.clj",
                              :source "(defn- relative-tabulation [params navigator offsets]\n  (let [colrel (:colnum params) \n        colinc (:colinc params)\n        start-col (+ colrel (get-column (:base @@*out*)))\n        offset (if (pos? colinc) (rem start-col colinc) 0)\n        space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)"},
       "format-simple-ordinal" {:type "defn-",
                                :key "format-simple-ordinal",
                                :lines [380 400],
                                :filename "cl_format.clj",
                                :source "(defn- format-simple-ordinal\n  \"Convert a number less than 1000 to a ordinal english string\nNote this should only be used for the last one in the sequence\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n     (if (and (pos? hundreds) (pos? tens)) \" \")\n     (if (pos? tens) \n       (if (< tens 20) \n         (nth english-ordinal-units tens)\n         (let [ten-digit (quot tens 10)\n               unit-digit (rem tens 10)]\n           (if (and (pos? ten-digit) (not (pos? unit-digit)))\n             (nth english-ordinal-tens ten-digit)\n             (str\n              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n              (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n              (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))\n       (if (pos? hundreds) \"th\")))))"},
       "arg-navigator" {:type "defstruct",
                        :key "arg-navigator",
                        :lines [79 80],
                        :filename "cl_format.clj",
                        :source "(defstruct ^{:private true}\n  arg-navigator :seq :rest :pos )"},
       "special-chars" {:type "def",
                        :key "special-chars",
                        :lines [487 488],
                        :filename "cl_format.clj",
                        :source "(def ^{:private true} \n     special-chars { 8 \"Backspace\", 9 \"Tab\",  10 \"Newline\", 13 \"Return\", 32 \"Space\"})"},
       "write-out" {:type "defn",
                    :key "write-out",
                    :lines [171 195],
                    :filename "pprint_base.clj",
                    :source "(defn write-out \n  \"Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \\\"write\\\" interface. \"\n  {:added \"1.2\"}\n  [object]\n  (let [length-reached (and \n                        *current-length*\n                        *print-length*\n                        (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (print \"...\")\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))"},
       "emit-nl? :mandatory" {:type "defmethod",
                              :key "emit-nl? :mandatory",
                              :lines [194 195],
                              :filename "pretty_writer.clj",
                              :source "(defmethod emit-nl? :mandatory [_ _ _ _]\n  true)"},
       "write-token :end-block-t" {:type "defmethod",
                                   :key "write-token :end-block-t",
                                   :lines [114 117],
                                   :filename "pretty_writer.clj",
                                   :source "(defmethod write-token :end-block-t [^Writer this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :end))\n  (when-let [^String suffix (:suffix (:logical-block token))] \n    (.write (getf :base) suffix)))"},
       "compile-raw-string" {:type "defn-",
                             :key "compile-raw-string",
                             :lines [1735 1736],
                             :filename "cl_format.clj",
                             :source "(defn- compile-raw-string [s offset]\n  (struct compiled-directive (fn [_ a _] (print s) a) nil { :string s } offset))"},
       "unzip-map" {:type "defn-",
                    :key "unzip-map",
                    :lines [53 58],
                    :filename "utilities.clj",
                    :source "(defn- unzip-map [m]\n  \"Take a  map that has pairs in the value slots and produce a pair of maps, \n   the first having all the first elements of the pairs and the second all \n   the second elements of the pairs\"\n  [(into {} (for [[k [v1 v2]] m] [k v1]))\n   (into {} (for [[k [v1 v2]] m] [k v2]))])"},
       "pr-with-base" {:type "defn-",
                       :key "pr-with-base",
                       :lines [113 116],
                       :filename "pprint_base.clj",
                       :source "(defn- pr-with-base [x]\n  (if-let [s (format-simple-number x)]\n    (print s)\n    (orig-pr x)))"},
       "write-token :indent-t" {:type "defmethod",
                                :key "write-token :indent-t",
                                :lines [119 125],
                                :filename "pretty_writer.clj",
                                :source "(defmethod write-token :indent-t [^Writer this token]\n  (let [lb (:logical-block token)]\n    (ref-set (:indent lb) \n             (+ (:offset token)\n                (condp = (:relative-to token)\n\t\t  :block @(:start-col lb)\n\t\t  :current (get-column (getf :base)))))))"},
       "realize-parameter" {:type "defn-",
                            :key "realize-parameter",
                            :lines [134 148],
                            :filename "cl_format.clj",
                            :source "(defn- realize-parameter [[param [raw-val offset]] navigator]\n  (let [[real-param new-navigator]\n        (cond \n         (contains? #{ :at :colon } param) ;pass flags through unchanged - this really isn't necessary\n         [raw-val navigator]\n\n         (= raw-val :parameter-from-args) \n         (next-arg navigator)\n\n         (= raw-val :remaining-arg-count) \n         [(count (:rest navigator)) navigator]\n\n         true \n         [raw-val navigator])]\n    [[param [real-param offset]] new-navigator]))"},
       "process-directive-table-element" {:type "defn-",
                                          :key "process-directive-table-element",
                                          :lines [1320 1326],
                                          :filename "cl_format.clj",
                                          :source "(defn- process-directive-table-element [ [ char params flags bracket-info & generator-fn ] ]\n  [char, \n   {:directive char,\n    :params `(array-map ~@params),\n    :flags flags,\n    :bracket-info bracket-info,\n    :generator-fn (concat '(fn [ params offset]) generator-fn) }])"},
       "java-base-formats" {:type "def",
                            :key "java-base-formats",
                            :lines [242 243],
                            :filename "cl_format.clj",
                            :source "(def ^{:private true}\n     java-base-formats {8 \"%o\", 10 \"%d\", 16 \"%x\"})"},
       "end-block" {:type "defn-",
                    :key "end-block",
                    :lines [452 466],
                    :filename "pretty_writer.clj",
                    :source "(defn- end-block [^Writer this]\n  (dosync\n   (let [lb (getf :logical-blocks)\n         ^String suffix (:suffix lb)]\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n         (if suffix\n           (.write (getf :base) suffix))\n         (when-let [cb (getf :logical-block-callback)] (cb :end)))\n       (let [oldpos (getf :pos)\n             newpos (+ oldpos (if suffix (count suffix) 0))]\n         (setf :pos newpos)\n         (add-to-buffer this (make-end-block-t lb oldpos newpos))))\n     (setf :logical-blocks (:parent lb)))))"},
       "add-core-ns" {:type "defn-",
                      :key "add-core-ns",
                      :lines [409 416],
                      :filename "dispatch.clj",
                      :source "(defn- add-core-ns [amap]\n  (let [core \"clojure.core\"]\n    (into {}\n          (map #(let [[s f] %] \n                  (if (not (or (namespace s) (special-symbol? s)))\n                    [(symbol core (name s)) f]\n                    %))\n               amap))))"},
       "set-miser-width" {:type "defn-",
                          :key "set-miser-width",
                          :lines [490 491],
                          :filename "pretty_writer.clj",
                          :source "(defn- set-miser-width [^Writer this new-miser-width]\n  (dosync (setf :miser-width new-miser-width)))"},
       "prerr" {:type "defn-",
                :key "prerr",
                :lines [95 98],
                :filename "utilities.clj",
                :source "(defn- prerr [& args]\n  \"Println to *err*\"\n  (binding [*out* *err*]\n    (apply println args)))"},
       "prefix-count" {:type "defn-",
                       :key "prefix-count",
                       :lines [85 93],
                       :filename "utilities.clj",
                       :source "(defn- prefix-count [aseq val]\n  \"Return the number of times that val occurs at the start of sequence aseq, \nif val is a seq itself, count the number of times any element of val occurs at the\nbeginning of aseq\"\n  (let [test (if (coll? val) (set val) #{val})]\n    (loop [pos 0]\n     (if (or (= pos (count aseq)) (not (test (nth aseq pos))))\n       pos\n       (recur (inc pos))))))"},
       "format-logical-block" {:type "defn-",
                               :key "format-logical-block",
                               :lines [1282 1298],
                               :filename "cl_format.clj",
                               :source "(defn- format-logical-block [params navigator offsets]\n  (let [clauses (:clauses params)\n        clause-count (count clauses)\n        prefix (cond\n                (> clause-count 1) (:string (:params (first (first clauses))))\n                (:colon params) \"(\")\n        body (nth clauses (if (> clause-count 1) 1 0))\n        suffix (cond\n                (> clause-count 2) (:string (:params (first (nth clauses 2))))\n                (:colon params) \")\")\n        [arg navigator] (next-arg navigator)]\n    (pprint-logical-block :prefix prefix :suffix suffix\n      (execute-sub-format \n       body \n       (init-navigator arg)\n       (:base-args params)))\n    navigator))"},
       "pprint-reader-macro" {:type "defn-",
                              :key "pprint-reader-macro",
                              :lines [49 54],
                              :filename "dispatch.clj",
                              :source "(defn- pprint-reader-macro [alis]\n  (let [^String macro-char (reader-macros (first alis))]\n    (when (and macro-char (= 2 (count alis)))\n      (.write ^java.io.Writer *out* macro-char)\n      (write-out (second alis))\n      true)))"},
       "pretty-writer?" {:type "defn-",
                         :key "pretty-writer?",
                         :lines [151 153],
                         :filename "pprint_base.clj",
                         :source "(defn- pretty-writer? \n  \"Return true iff x is a PrettyWriter\"\n  [x] (and (instance? clojure.lang.IDeref x) (:pretty-writer @@x)))"},
       "base-str" {:type "defn-",
                   :key "base-str",
                   :lines [227 240],
                   :filename "cl_format.clj",
                   :source "(defn- base-str\n  \"Return val as a string in the given base\"\n  [base val]\n  (if (zero? val)\n    \"0\"\n    (let [xlated-val (cond\n                       (float? val) (bigdec val)\n                       (ratio? val) (let [^clojure.lang.Ratio r val] \n                                      (/ (.numerator r) (.denominator r)))\n                       :else val)] \n      (apply str \n             (map \n              #(if (< % 10) (char (+ (int \\0) %)) (char (+ (int \\a) (- % 10)))) \n              (remainders base val))))))"},
       "*print-miser-width*" {:type "def",
                              :key "*print-miser-width*",
                              :lines [47 52],
                              :filename "pprint_base.clj",
                              :source "(def ^:dynamic\n ^{:doc \"The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.\",\n   :added \"1.2\"}\n *print-miser-width* 40)"},
       "pprint-tab" {:type "defn",
                     :key "pprint-tab",
                     :lines [356 371],
                     :filename "pprint_base.clj",
                     :source "(defn pprint-tab \n  \"Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n  {:added \"1.2\"}\n  [kind colnum colinc] \n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (UnsupportedOperationException. \"pprint-tab is not yet implemented\")))"},
       "check-arg-conditional" {:type "defn-",
                                :key "check-arg-conditional",
                                :lines [867 875],
                                :filename "cl_format.clj",
                                :source "(defn- check-arg-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg (first clauses))]\n    (if arg\n      (if clause\n        (execute-sub-format clause arg-navigator (:base-args params))\n        arg-navigator)\n      navigator)))"},
       "use-method" {:type "defn-",
                     :key "use-method",
                     :lines [20 23],
                     :filename "dispatch.clj",
                     :source "(defn- use-method\n  \"Installs a function as a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val func]\n  (. multifn addMethod dispatch-val func))"},
       "print-length-loop" {:type "defmacro",
                            :key "print-length-loop",
                            :lines [391 401],
                            :filename "pprint_base.clj",
                            :source "(defmacro print-length-loop\n  \"A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.\"\n  {:added \"1.3\"}\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not *print-length*) (< ~count-var *print-length*))\n         (do ~@mod-body)\n         (.write ^java.io.Writer *out* \"...\")))))"},
       "pprint-newline" {:type "defn",
                         :key "pprint-newline",
                         :lines [329 339],
                         :filename "pprint_base.clj",
                         :source "(defn pprint-newline\n  \"Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  {:added \"1.2\"}\n  [kind] \n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))"},
       "*print-base*" {:type "def",
                       :key "*print-base*",
                       :lines [87 90],
                       :filename "pprint_base.clj",
                       :source "(def ^:dynamic\n ^{:doc \"The base to use for printing integers and rationals.\"\n   :added \"1.2\"}\n *print-base* 10)"},
       "process-clause" {:type "defn-",
                         :key "process-clause",
                         :lines [1756 1778],
                         :filename "cl_format.clj",
                         :source "(defn- process-clause [bracket-info offset remainder]\n  (consume \n   (fn [remainder]\n     (if (empty? remainder)\n       (format-error \"No closing bracket found.\" offset)\n       (let [this (first remainder)\n             remainder (next remainder)]\n         (cond\n          (right-bracket this)\n          (process-bracket this remainder)\n\n          (= (:right bracket-info) (:directive (:def this)))\n          [ nil [:right-bracket (:params this) nil remainder]]\n\n          (else-separator? this)\n          [nil [:else nil (:params this) remainder]]\n\n          (separator? this)\n          [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;\n\n          true\n          [this remainder]))))\n   remainder))"},
       "multi-defn" {:type "defn-",
                     :key "multi-defn",
                     :lines [262 264],
                     :filename "dispatch.clj",
                     :source "(defn- multi-defn [alis has-doc-str?]\n  (if (seq alis)\n    ((formatter-out \" ~_~{~w~^ ~_~}\") alis)))"},
       "*format-str*" {:type "def",
                       :key "*format-str*",
                       :lines [66 66],
                       :filename "cl_format.clj",
                       :source "(def ^:dynamic ^{:private true} *format-str* nil)"},
       "reader-macros" {:type "def",
                        :key "reader-macros",
                        :lines [45 47],
                        :filename "dispatch.clj",
                        :source "(def ^{:private true} reader-macros\n     {'quote \"'\", 'clojure.core/deref \"@\", \n      'var \"#'\", 'clojure.core/unquote \"~\"})"},
       "getf" {:type "defmacro",
               :key "getf",
               :lines [37 41],
               :filename "pretty_writer.clj",
               :source "(defmacro ^{:private true} \n  getf \n  \"Get the value of the field a named by the argument (which should be a keyword).\"\n  [sym]\n  `(~sym @@~'this))"},
       "else-separator?" {:type "defn-",
                          :key "else-separator?",
                          :lines [1740 1742],
                          :filename "cl_format.clj",
                          :source "(defn- else-separator? [this] \n  (and (:separator (:bracket-info (:def this)))\n       (:colon (:params this))))"},
       "pprint-anon-func" {:type "defn-",
                           :key "pprint-anon-func",
                           :lines [367 379],
                           :filename "dispatch.clj",
                           :source "(defn- pprint-anon-func [alis]\n  (let [args (second alis)\n        nlis (first (rest (rest alis)))]\n    (if (vector? args)\n      (binding [*symbol-map* (if (= 1 (count args)) \n                               {(first args) \"%\"}\n                               (into {} \n                                     (map \n                                      #(vector %1 (str \\% %2)) \n                                      args \n                                      (range 1 (inc (count args))))))]\n        ((formatter-out \"~<#(~;~@{~w~^ ~_~}~;)~:>\") nlis))\n      (pprint-simple-code-list alis))))"},
       "set-indent" {:type "defn-",
                     :key "set-indent",
                     :lines [1300 1303],
                     :filename "cl_format.clj",
                     :source "(defn- set-indent [params navigator offsets]\n  (let [relative-to (if (:colon params) :current :block)]\n    (pprint-indent relative-to (:n params))\n    navigator))"},
       "write-token :nl-t" {:type "defmethod",
                            :key "write-token :nl-t",
                            :lines [130 139],
                            :filename "pretty_writer.clj",
                            :source "(defmethod write-token :nl-t [^Writer this token]\n;  (prlabel wt @(:done-nl (:logical-block token)))\n;  (prlabel wt (:type token) (= (:type token) :mandatory))\n  (if (or (= (:type token) :mandatory)\n           (and (not (= (:type token) :fill))\n                @(:done-nl (:logical-block token))))\n    (emit-nl this token)\n    (if-let [^String tws (getf :trailing-white-space)]\n      (.write (getf :base) tws)))\n  (dosync (setf :trailing-white-space nil)))"},
       "extract-flags" {:type "defn-",
                        :key "extract-flags",
                        :lines [1657 1670],
                        :filename "cl_format.clj",
                        :source "(defn- extract-flags [s offset]\n  (consume\n   (fn [[s offset flags]]\n     (if (empty? s)\n       [nil [s offset flags]]\n       (let [flag (get flag-defs (first s))]\n         (if flag\n           (if (contains? flags flag)\n             (format-error \n              (str \"Flag \\\"\" (first s) \"\\\" appears more than once in a directive\")\n              offset)\n             [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])\n           [nil [s offset flags]]))))\n   [s offset {}]))"},
       "english-cardinal-tens" {:type "def",
                                :key "english-cardinal-tens",
                                :lines [301 303],
                                :filename "cl_format.clj",
                                :source "(def ^{:private true}\n     english-cardinal-tens\n     [\"\" \"\" \"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"])"},
       "integral?" {:type "defn-",
                    :key "integral?",
                    :lines [205 214],
                    :filename "cl_format.clj",
                    :source "(defn- integral?\n  \"returns true if a number is actually an integer (that is, has no fractional part)\"\n  [x]\n  (cond\n   (integer? x) true\n   (decimal? x) (>= (.ulp (.stripTrailingZeros (bigdec 0))) 1) ; true iff no fractional part\n   (float? x)   (= x (Math/floor x))\n   (ratio? x)   (let [^clojure.lang.Ratio r x]\n                  (= 0 (rem (.numerator r) (.denominator r))))\n   :else        false))"},
       "write-token :start-block-t" {:type "defmethod",
                                     :key "write-token :start-block-t",
                                     :lines [104 112],
                                     :filename "pretty_writer.clj",
                                     :source "(defmethod write-token :start-block-t [^Writer this token]\n   (when-let [cb (getf :logical-block-callback)] (cb :start))\n   (let [lb (:logical-block token)]\n    (dosync\n     (when-let [^String prefix (:prefix lb)] \n       (.write (getf :base) prefix))\n     (let [col (get-column (getf :base))]\n       (ref-set (:start-col lb) col)\n       (ref-set (:indent lb) col)))))"},
       "section" {:type "defstruct",
                  :key "section",
                  :lines [75 75],
                  :filename "pretty_writer.clj",
                  :source "(defstruct ^{:private true} section :parent)"},
       "*current-level*" {:type "def",
                          :key "*current-level*",
                          :lines [99 99],
                          :filename "pprint_base.clj",
                          :source "(def  ^:dynamic ^{ :private true } *current-level* 0)"},
       "extract-params" {:type "defn-",
                         :key "extract-params",
                         :lines [1639 1640],
                         :filename "cl_format.clj",
                         :source "(defn- extract-params [s offset] \n  (consume extract-param [s offset false]))"},
       "*default-page-width*" {:type "def",
                               :key "*default-page-width*",
                               :lines [23 23],
                               :filename "column_writer.clj",
                               :source "(def ^:dynamic ^{:private true} *default-page-width* 72)"},
       "*print-radix*" {:type "def",
                        :key "*print-radix*",
                        :lines [80 85],
                        :filename "pprint_base.clj",
                        :source "(def ^:dynamic\n ^{:doc \"Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* \"\n   :added \"1.2\"}\n *print-radix* nil)"},
       "pprint-indent" {:type "defn",
                        :key "pprint-indent",
                        :lines [341 353],
                        :filename "pprint_base.clj",
                        :source "(defn pprint-indent \n  \"Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  {:added \"1.2\"}\n  [relative-to n] \n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))"},
       "write-initial-lines" {:type "defn-",
                              :key "write-initial-lines",
                              :lines [324 348],
                              :filename "pretty_writer.clj",
                              :source "(defn- write-initial-lines \n  [^Writer this ^String s] \n  (let [lines (.split s \"\\n\" -1)]\n    (if (= (count lines) 1)\n      s\n      (dosync \n       (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))\n             ^String l (first lines)] \n         (if (= :buffering (getf :mode))\n           (let [oldpos (getf :pos)\n                 newpos (+ oldpos (count l))]\n             (setf :pos newpos)\n             (add-to-buffer this (make-buffer-blob l nil oldpos newpos))\n             (write-buffered-output this))\n           (do\n             (write-white-space this)\n             (.write (getf :base) l)))\n         (.write (getf :base) (int \\newline))\n         (doseq [^String l (next (butlast lines))]\n           (.write (getf :base) l)\n           (.write (getf :base) (pp-newline))\n           (if prefix\n             (.write (getf :base) prefix)))\n         (setf :buffering :writing)\n         (last lines))))))"},
       "orig-pr" {:type "def",
                  :key "orig-pr",
                  :lines [111 111],
                  :filename "pprint_base.clj",
                  :source "(def ^{:private true} orig-pr pr)"},
       "prlabel" {:type "defmacro",
                  :key "prlabel",
                  :lines [100 103],
                  :filename "utilities.clj",
                  :source "(defmacro ^{:private true} prlabel [prefix arg & more-args]\n  \"Print args to *err* in name = value format\"\n  `(prerr ~@(cons (list 'quote prefix) (mapcat #(list (list 'quote %) \"=\" %) \n                                                  (cons arg (seq more-args))))))"},
       "absolute-tabulation" {:type "defn-",
                              :key "absolute-tabulation",
                              :lines [1255 1264],
                              :filename "cl_format.clj",
                              :source "(defn- absolute-tabulation [params navigator offsets]\n  (let [colnum (:colnum params) \n        colinc (:colinc params)\n        current (get-column (:base @@*out*))\n        space-count (cond\n                     (< current colnum) (- colnum current)\n                     (= colinc 0) 0\n                     :else (- colinc (rem (- current colnum) colinc)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)"},
       "special-params" {:type "def",
                         :key "special-params",
                         :lines [1621 1622],
                         :filename "cl_format.clj",
                         :source "(def ^{:private true}\n     special-params #{ :parameter-from-args :remaining-arg-count })"},
       "ltrim" {:type "defn-",
                :key "ltrim",
                :lines [75 83],
                :filename "utilities.clj",
                :source "(defn- ltrim [s c]\n  \"Trim all instances of c from the beginning of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s 0) c))\n      (loop [n 0]\n        (if (or (= n len) (not (= (nth s n) c)))\n          (subs s n)\n          (recur (inc n))))\n      s)))"},
       "logical-block" {:type "defstruct",
                        :key "logical-block",
                        :lines [62 66],
                        :filename "pretty_writer.clj",
                        :source "(defstruct ^{:private true} logical-block\n           :parent :section :start-col :indent\n           :done-nl :intra-block-nl\n           :prefix :per-line-prefix :suffix\n           :logical-block-callback)"},
       "set-max-column" {:type "defn-",
                         :key "set-max-column",
                         :lines [40 42],
                         :filename "column_writer.clj",
                         :source "(defn- set-max-column [this new-max]\n  (dosync (set-field this :max new-max))\n  nil)"},
       "english-cardinal-units" {:type "def",
                                 :key "english-cardinal-units",
                                 :lines [289 293],
                                 :filename "cl_format.clj",
                                 :source "(def ^{:private true}\n     english-cardinal-units \n     [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"\n      \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\n      \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"])"},
       "indent" {:type "defn-",
                 :key "indent",
                 :lines [474 485],
                 :filename "pretty_writer.clj",
                 :source "(defn- indent [^Writer this relative-to offset]\n  (dosync \n   (let [lb (getf :logical-blocks)]\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n         (ref-set (:indent lb) \n                  (+ offset (condp = relative-to\n\t\t\t      :block @(:start-col lb)\n\t\t\t      :current (get-column (getf :base))))))\n       (let [pos (getf :pos)]\n         (add-to-buffer this (make-indent-t lb relative-to offset pos pos)))))))"},
       "expand-fixed" {:type "defn-",
                       :key "expand-fixed",
                       :lines [627 635],
                       :filename "cl_format.clj",
                       :source "(defn- expand-fixed [m e d]\n  (let [[m1 e1] (if (neg? e)\n                  [(str (apply str (repeat (dec (- e)) \\0)) m) -1]\n                  [m e])\n        len (count m1)\n        target-len (if d (+ e1 d 1) (inc e1))]\n    (if (< len target-len) \n      (str m1 (apply str (repeat (- target-len len) \\0))) \n      m1)))"},
       "pprint-binding-form" {:type "defn-",
                              :key "pprint-binding-form",
                              :lines [293 306],
                              :filename "dispatch.clj",
                              :source "(defn- pprint-binding-form [binding-vec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [binding binding-vec]\n      (when (seq binding)\n        (pprint-logical-block binding\n          (write-out (first binding))\n          (when (next binding)\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second binding))))\n        (when (next (rest binding))\n          (.write ^java.io.Writer *out* \" \")\n          (pprint-newline :linear)\n          (recur (next (rest binding))))))))"},
       "toks" {:type "defn-",
               :key "toks",
               :lines [252 252],
               :filename "pretty_writer.clj",
               :source "(defn- toks [toks] (map tok toks))"},
       "pprint-simple-default" {:type "defn-",
                                :key "pprint-simple-default",
                                :lines [140 144],
                                :filename "dispatch.clj",
                                :source "(defn- pprint-simple-default [obj]\n  (cond \n    (.isArray (class obj)) (pprint-array obj)\n    (and *print-suppress-namespaces* (symbol? obj)) (print (name obj))\n    :else (pr obj)))"},
       "modify-case" {:type "defn-",
                      :key "modify-case",
                      :lines [1194 1197],
                      :filename "cl_format.clj",
                      :source "(defn- modify-case [make-writer params navigator offsets]\n  (let [clause (first (:clauses params))]\n    (binding [*out* (make-writer *out*)] \n      (execute-sub-format clause navigator (:base-args params)))))"},
       "pprint-simple-list" {:type "defn-",
                             :key "pprint-simple-list",
                             :lines [66 74],
                             :filename "dispatch.clj",
                             :source "(defn- pprint-simple-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (print-length-loop [alis (seq alis)]\n      (when alis\n\t(write-out (first alis))\n\t(when (next alis)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next alis)))))))"},
       "emit-nl?" {:type "defmulti",
                   :key "emit-nl?",
                   :lines [178 178],
                   :filename "pretty_writer.clj",
                   :source "(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))"},
       "pp" {:type "defmacro",
             :key "pp",
             :lines [254 258],
             :filename "pprint_base.clj",
             :source "(defmacro pp \n  \"A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).\"\n  {:added \"1.2\"}\n  [] `(pprint *1))"},
       "set-logical-block-callback" {:type "defn-",
                                     :key "set-logical-block-callback",
                                     :lines [493 494],
                                     :filename "pretty_writer.clj",
                                     :source "(defn- set-logical-block-callback [^Writer this f]\n  (dosync (setf :logical-block-callback f)))"},
       "fresh-line" {:type "defn",
                     :key "fresh-line",
                     :lines [1245 1253],
                     :filename "cl_format.clj",
                     :source "(defn fresh-line\n  \"Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n  {:added \"1.2\"}\n  []\n  (if (instance? clojure.lang.IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))"},
       "format-simple-number" {:type "defn-",
                               :key "format-simple-number",
                               :lines [168 180],
                               :filename "cl_format.clj",
                               :source "(defn- format-simple-number [n]\n  (cond \n    (integer? n) (if (= *print-base* 10)\n                   (str n (if *print-radix* \".\"))\n                   (str\n                    (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                    (opt-base-str *print-base* n)))\n    (ratio? n) (str\n                (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                (opt-base-str *print-base* (.numerator n))\n                \"/\"\n                (opt-base-str *print-base* (.denominator n)))\n    :else nil))"},
       "format-error" {:type "defn-",
                       :key "format-error",
                       :lines [68 71],
                       :filename "cl_format.clj",
                       :source "(defn- format-error [message offset] \n  (let [full-message (str message \\newline *format-str* \\newline \n                           (apply str (repeat offset \\space)) \"^\" \\newline)]\n    (throw (RuntimeException. full-message))))"},
       "get-column" {:type "defn-",
                     :key "get-column",
                     :lines [31 32],
                     :filename "column_writer.clj",
                     :source "(defn- get-column [this]\n  (get-field this :cur))"},
       "start-block" {:type "defn-",
                      :key "start-block",
                      :lines [430 450],
                      :filename "pretty_writer.clj",
                      :source "(defn- start-block \n  [^Writer this \n   ^String prefix ^String per-line-prefix ^String suffix]\n  (dosync \n   (let [lb (struct logical-block (getf :logical-blocks) nil (ref 0) (ref 0)\n                    (ref false) (ref false)\n                    prefix per-line-prefix suffix)]\n     (setf :logical-blocks lb)\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n          (when-let [cb (getf :logical-block-callback)] (cb :start))\n          (if prefix \n           (.write (getf :base) prefix))\n         (let [col (get-column (getf :base))]\n           (ref-set (:start-col lb) col)\n           (ref-set (:indent lb) col)))\n       (let [oldpos (getf :pos)\n             newpos (+ oldpos (if prefix (count prefix) 0))]\n         (setf :pos newpos)\n         (add-to-buffer this (make-start-block-t lb oldpos newpos)))))))"},
       "binding-map" {:type "defmacro",
                      :key "binding-map",
                      :lines [137 144],
                      :filename "pprint_base.clj",
                      :source "(defmacro ^{:private true} binding-map [amap & body]\n  (let []\n    `(do\n       (. clojure.lang.Var (pushThreadBindings ~amap))\n       (try\n        ~@body\n        (finally\n         (. clojure.lang.Var (popThreadBindings)))))))"},
       "write-token" {:type "defmulti",
                      :key "write-token",
                      :lines [103 103],
                      :filename "pretty_writer.clj",
                      :source "(defmulti ^{:private true} write-token #(:type-tag %2))"},
       "write-token-string" {:type "defn-",
                             :key "write-token-string",
                             :lines [257 285],
                             :filename "pretty_writer.clj",
                             :source "(defn- write-token-string [this tokens]\n  (let [[a b] (split-at-newline tokens)]\n;;    (prlabel wts (toks a) (toks b))\n    (if a (write-tokens this a false))\n    (if b\n      (let [[section remainder] (get-section b)\n            newl (first b)]\n;;         (prlabel wts (toks section)) (prlabel wts (:type newl)) (prlabel wts (toks remainder)) \n        (let [do-nl (emit-nl? newl this section (get-sub-section b))\n              result (if do-nl \n                       (do\n;;                          (prlabel emit-nl (:type newl))\n                         (emit-nl this newl)\n                         (next b))\n                       b)\n              long-section (not (tokens-fit? this result))\n              result (if long-section\n                       (let [rem2 (write-token-string this section)]\n;;;                              (prlabel recurse (toks rem2))\n                         (if (= rem2 section)\n                           (do ; If that didn't produce any output, it has no nls\n                                        ; so we'll force it\n                             (write-tokens this section false)\n                             remainder)\n                           (into [] (concat rem2 remainder))))\n                       result)\n;;              ff (prlabel wts (toks result))\n              ] \n          result)))))"},
       "column-writer" {:type "defn-",
                        :key "column-writer",
                        :lines [55 83],
                        :filename "column_writer.clj",
                        :source "(defn- column-writer   \n  ([writer] (column-writer writer *default-page-width*))\n  ([writer max-columns]\n     (let [fields (ref {:max max-columns, :cur 0, :line 0 :base writer})]\n       (proxy [Writer IDeref] []\n         (deref [] fields)\n         (flush []\n           (.flush writer))\n         (write\n          ([^chars cbuf ^Integer off ^Integer len] \n             (let [^Writer writer (get-field this :base)] \n               (.write writer cbuf off len)))\n          ([x]\n             (condp = (class x)\n               String \n               (let [^String s x\n                     nl (.lastIndexOf s (int \\newline))]\n                 (dosync (if (neg? nl)\n                           (set-field this :cur (+ (get-field this :cur) (count s)))\n                           (do\n                             (set-field this :cur (- (count s) nl 1))\n                             (set-field this :line (+ (get-field this :line)\n                                                      (count (filter #(= % \\newline) s)))))))\n                 (.write ^Writer (get-field this :base) s))\n\n               Integer\n               (c-write-char this x)\n               Long\n               (c-write-char this x))))))))"},
       "downcase-writer" {:type "defn-",
                          :key "downcase-writer",
                          :lines [1072 1088],
                          :filename "cl_format.clj",
                          :source "(defn- downcase-writer \n  \"Returns a proxy that wraps writer, converting all characters to lower case\"\n  [^java.io.Writer writer]\n  (proxy [java.io.Writer] []\n    (close [] (.close writer))\n    (flush [] (.flush writer))\n    (write ([^chars cbuf ^Integer off ^Integer len] \n              (.write writer cbuf off len))\n           ([x]\n              (condp = (class x)\n\t\tString \n\t\t(let [s ^String x]\n\t\t  (.write writer (.toLowerCase s)))\n\n\t\tInteger\n\t\t(let [c ^Character x]\n\t\t  (.write writer (int (Character/toLowerCase (char c))))))))))"},
       "update-nl-state" {:type "defn-",
                          :key "update-nl-state",
                          :lines [217 225],
                          :filename "pretty_writer.clj",
                          :source "(defn- update-nl-state [lb]\n  (dosync\n   (ref-set (:intra-block-nl lb) false)\n   (ref-set (:done-nl lb) true)\n   (loop [lb (:parent lb)]\n     (if lb\n       (do (ref-set (:done-nl lb) true)\n           (ref-set (:intra-block-nl lb) true)\n           (recur (:parent lb)))))))"},
       "format-cardinal-english" {:type "defn-",
                                  :key "format-cardinal-english",
                                  :lines [363 378],
                                  :filename "cl_format.clj",
                                  :source "(defn- format-cardinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zero\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal parts)\n                full-str (add-english-scales parts-strs 0)]\n            (print (str (if (neg? arg) \"minus \") full-str)))\n          (format-integer ;; for numbers > 10^63, we fall back on ~D\n           10\n           { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n           (init-navigator [arg])\n           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))\n    navigator))"},
       "format-simple-cardinal" {:type "defn-",
                                 :key "format-simple-cardinal",
                                 :lines [322 338],
                                 :filename "cl_format.clj",
                                 :source "(defn- format-simple-cardinal\n  \"Convert a number less than 1000 to a cardinal english string\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n     (if (and (pos? hundreds) (pos? tens)) \" \")\n     (if (pos? tens) \n       (if (< tens 20) \n         (nth english-cardinal-units tens)\n         (let [ten-digit (quot tens 10)\n               unit-digit (rem tens 10)]\n           (str\n            (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n            (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n            (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))"},
       "cached-compile" {:type "def",
                         :key "cached-compile",
                         :lines [1913 1913],
                         :filename "cl_format.clj",
                         :source "(def ^{:private true} cached-compile (memoize compile-format))"},
       "*print-pretty*" {:type "def",
                         :key "*print-pretty*",
                         :lines [30 32],
                         :filename "pprint_base.clj",
                         :source "(def ^:dynamic\n ^{:doc \"Bind to true if you want write to use pretty printing\", :added \"1.2\"}\n *print-pretty* true)"},
       "get-fixed" {:type "defn-",
                    :key "get-fixed",
                    :lines [645 646],
                    :filename "cl_format.clj",
                    :source "(defn- get-fixed [m e d]\n  (insert-decimal (expand-fixed m e d) e))"},
       "pprint-pqueue" {:type "def",
                        :key "pprint-pqueue",
                        :lines [138 138],
                        :filename "dispatch.clj",
                        :source "(def ^{:private true} pprint-pqueue (formatter-out \"~<<-(~;~@{~w~^ ~_~}~;)-<~:>\"))"},
       "readable-character" {:type "defn-",
                             :key "readable-character",
                             :lines [504 510],
                             :filename "cl_format.clj",
                             :source "(defn- readable-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)]\n    (condp = (:char-format params)\n      \\o (cl-format true \"\\\\o~3,'0o\" (int c))\n      \\u (cl-format true \"\\\\u~4,'0x\" (int c))\n      nil (pr c))\n    navigator))"},
       "capitalize-string" {:type "defn-",
                            :key "capitalize-string",
                            :lines [1108 1130],
                            :filename "cl_format.clj",
                            :source "(defn- capitalize-string\n  \"Capitalizes the words in a string. If first? is false, don't capitalize the \n                                      first character of the string even if it's a letter.\"\n  [s first?]\n  (let [^Character f (first s) \n        s (if (and first? f (Character/isLetter f))\n            (str (Character/toUpperCase f) (subs s 1))\n            s)]\n    (apply str \n           (first\n            (consume\n             (fn [s]\n               (if (empty? s)\n                 [nil nil]\n                 (let [m (re-matcher #\"\\W\\w\" s)\n                       match (re-find m)\n                       offset (and match (inc (.start m)))]\n                   (if offset\n                     [(str (subs s 0 offset) \n                           (Character/toUpperCase ^Character (nth s offset)))\n                      (subs s (inc offset))]\n                     [s nil]))))\n             s)))))"},
       "indent-t" {:type "deftype",
                   :key "indent-t",
                   :lines [93 93],
                   :filename "pretty_writer.clj",
                   :source "(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)"},
       "abort?" {:type "defn-",
                 :key "abort?",
                 :lines [519 521],
                 :filename "cl_format.clj",
                 :source "(defn- abort? [context]\n  (let [token (first context)]\n    (or (= :up-arrow token) (= :colon-up-arrow token))))"},
       "exponential-float" {:type "defn-",
                            :key "exponential-float",
                            :lines [720 787],
                            :filename "cl_format.clj",
                            :source "(defn- exponential-float [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)\n        arg (convert-ratio arg)]\n    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]\n      (let [w (:w params)\n            d (:d params)\n            e (:e params)\n            k (:k params)\n            expchar (or (:exponentchar params) \\E)\n            add-sign (or (:at params) (neg? arg))\n            prepend-zero (<= k 0)\n            ^Integer scaled-exp (- exp (dec k))\n            scaled-exp-str (str (Math/abs scaled-exp))\n            scaled-exp-str (str expchar (if (neg? scaled-exp) \\- \\+) \n                                (if e (apply str \n                                             (repeat \n                                              (- e \n                                                 (count scaled-exp-str)) \n                                              \\0))) \n                                scaled-exp-str)\n            exp-width (count scaled-exp-str)\n            base-mantissa-width (count mantissa)\n            scaled-mantissa (str (apply str (repeat (- k) \\0))\n                                 mantissa\n                                 (if d \n                                   (apply str \n                                          (repeat \n                                           (- d (dec base-mantissa-width)\n                                              (if (neg? k) (- k) 0)) \\0))))\n            w-mantissa (if w (- w exp-width))\n            [rounded-mantissa _ incr-exp] (round-str \n                                           scaled-mantissa 0\n                                           (cond\n                                            (= k 0) (dec d)\n                                            (pos? k) d\n                                            (neg? k) (dec d))\n                                           (if w-mantissa \n                                             (- w-mantissa (if add-sign 1 0))))\n            full-mantissa (insert-scaled-decimal rounded-mantissa k)\n            append-zero (and (= k (count rounded-mantissa)) (nil? d))]\n        (if (not incr-exp)\n          (if w\n            (let [len (+ (count full-mantissa) exp-width)\n                  signed-len (if add-sign (inc len) len)\n                  prepend-zero (and prepend-zero (not (= signed-len w)))\n                  full-len (if prepend-zero (inc signed-len) signed-len)\n                  append-zero (and append-zero (< full-len w))]\n              (if (and (or (> full-len w) (and e (> (- exp-width 2) e)))\n                       (:overflowchar params))\n                (print (apply str (repeat w (:overflowchar params))))\n                (print (str\n                        (apply str \n                               (repeat \n                                (- w full-len (if append-zero 1 0) )\n                                (:padchar params)))\n                        (if add-sign (if (neg? arg) \\- \\+)) \n                        (if prepend-zero \"0\")\n                        full-mantissa\n                        (if append-zero \"0\")\n                        scaled-exp-str))))\n            (print (str\n                    (if add-sign (if (neg? arg) \\- \\+)) \n                    (if prepend-zero \"0\")\n                    full-mantissa\n                    (if append-zero \"0\")\n                    scaled-exp-str)))\n          (recur [rounded-mantissa (inc exp)]))))\n    navigator))"},
       "pprint-list" {:type "defn-",
                      :key "pprint-list",
                      :lines [76 78],
                      :filename "dispatch.clj",
                      :source "(defn- pprint-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (pprint-simple-list alis)))"},
       "pprint-code-symbol" {:type "defn-",
                             :key "pprint-code-symbol",
                             :lines [441 446],
                             :filename "dispatch.clj",
                             :source "(defn- pprint-code-symbol [sym] \n  (if-let [arg-num (sym *symbol-map*)]\n    (print arg-num)\n    (if *print-suppress-namespaces* \n      (print (name sym))\n      (pr sym))))"},
       "justify-clauses" {:type "defn-",
                          :key "justify-clauses",
                          :lines [1017 1062],
                          :filename "cl_format.clj",
                          :source "(defn- justify-clauses [params navigator offsets]\n  (let [[[eol-str] new-navigator] (when-let [else (:else params)]\n                                    (render-clauses else navigator (:base-args params)))\n        navigator (or new-navigator navigator)\n        [else-params new-navigator] (when-let [p (:else-params params)]\n                                      (realize-parameter-list p navigator))\n        navigator (or new-navigator navigator)\n        min-remaining (or (first (:min-remaining else-params)) 0)\n        max-columns (or (first (:max-columns else-params))\n                        (get-max-column *out*))\n        clauses (:clauses params)\n        [strs navigator] (render-clauses clauses navigator (:base-args params))\n        slots (max 1\n                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))\n        chars (reduce + (map count strs))\n        mincol (:mincol params)\n        minpad (:minpad params)\n        colinc (:colinc params)\n        minout (+ chars (* slots minpad))\n        result-columns (if (<= minout mincol) \n                         mincol\n                         (+ mincol (* colinc\n                                      (+ 1 (quot (- minout mincol 1) colinc)))))\n        total-pad (- result-columns chars)\n        pad (max minpad (quot total-pad slots))\n        extra-pad (- total-pad (* pad slots))\n        pad-str (apply str (repeat pad (:padchar params)))]\n    (if (and eol-str (> (+ (get-column (:base @@*out*)) min-remaining result-columns) \n                        max-columns))\n      (print eol-str))\n    (loop [slots slots\n           extra-pad extra-pad\n           strs strs\n           pad-only (or (:colon params)\n                        (and (= (count strs) 1) (not (:at params))))]\n      (if (seq strs)\n        (do\n          (print (str (if (not pad-only) (first strs))\n                      (if (or pad-only (next strs) (:at params)) pad-str)\n                      (if (pos? extra-pad) (:padchar params))))\n          (recur \n           (dec slots)\n           (dec extra-pad)\n           (if pad-only strs (next strs))\n           false))))\n    navigator))"},
       "fixed-float" {:type "defn-",
                      :key "fixed-float",
                      :lines [672 714],
                      :filename "cl_format.clj",
                      :source "(defn- fixed-float [params navigator offsets]\n  (let [w (:w params)\n        d (:d params)\n        [arg navigator] (next-arg navigator)\n        [sign abs] (if (neg? arg) [\"-\" (- arg)] [\"+\" arg])\n        abs (convert-ratio abs)\n        [mantissa exp] (float-parts abs)\n        scaled-exp (+ exp (:k params))\n        add-sign (or (:at params) (neg? arg))\n        append-zero (and (not d) (<= (dec (count mantissa)) scaled-exp))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp \n                                                          d (if w (- w (if add-sign 1 0))))\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        fixed-repr (if (and w d\n                            (>= d 1)\n                            (= (.charAt fixed-repr 0) \\0)\n                            (= (.charAt fixed-repr 1) \\.)\n                            (> (count fixed-repr) (- w (if add-sign 1 0))))\n                     (subs fixed-repr 1)  ; chop off leading 0\n                     fixed-repr)\n        prepend-zero (= (first fixed-repr) \\.)]\n    (if w\n      (let [len (count fixed-repr)\n            signed-len (if add-sign (inc len) len)\n            prepend-zero (and prepend-zero (not (>= signed-len w)))\n            append-zero (and append-zero (not (>= signed-len w)))\n            full-len (if (or prepend-zero append-zero)\n                       (inc signed-len) \n                       signed-len)]\n        (if (and (> full-len w) (:overflowchar params))\n          (print (apply str (repeat w (:overflowchar params))))\n          (print (str\n                  (apply str (repeat (- w full-len) (:padchar params)))\n                  (if add-sign sign) \n                  (if prepend-zero \"0\")\n                  fixed-repr\n                  (if append-zero \"0\")))))\n      (print (str\n              (if add-sign sign) \n              (if prepend-zero \"0\")\n              fixed-repr\n              (if append-zero \"0\"))))\n    navigator))"},
       "get-section" {:type "defn-",
                      :key "get-section",
                      :lines [202 207],
                      :filename "pretty_writer.clj",
                      :source "(defn- get-section [buffer]\n  (let [nl (first buffer) \n        lb (:logical-block nl)\n        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))\n                                 (next buffer)))]\n    [section (seq (drop (inc (count section)) buffer))]))"},
       "get-max-column" {:type "defn-",
                         :key "get-max-column",
                         :lines [37 38],
                         :filename "column_writer.clj",
                         :source "(defn- get-max-column [this]\n  (get-field this :max))"},
       "emit-nl? :fill" {:type "defmethod",
                         :key "emit-nl? :fill",
                         :lines [188 192],
                         :filename "pretty_writer.clj",
                         :source "(defmethod emit-nl? :fill [newl this section subsection]\n  (let [lb (:logical-block newl)]\n    (or @(:intra-block-nl lb)\n        (not (tokens-fit? this subsection))\n        (miser-nl? this lb section))))"},
       "pprint-hold-first" {:type "def",
                            :key "pprint-hold-first",
                            :lines [246 246],
                            :filename "dispatch.clj",
                            :source "(def ^{:private true} pprint-hold-first (formatter-out \"~:<~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:>\"))"},
       "inc-s" {:type "defn-",
                :key "inc-s",
                :lines [569 583],
                :filename "cl_format.clj",
                :source "(defn- ^String inc-s\n  \"Assumption: The input string consists of one or more decimal digits,\nand no other characters.  Return a string containing one or more\ndecimal digits containing a decimal number one larger than the input\nstring.  The output string will always be the same length as the input\nstring, or one character longer.\"\n  [^String s]\n  (let [len-1 (dec (count s))]\n    (loop [i (int len-1)]\n      (cond\n       (neg? i) (apply str \"1\" (repeat (inc len-1) \"0\"))\n       (= \\9 (.charAt s i)) (recur (dec i))\n       :else (apply str (subs s 0 i)\n                    (char (inc (int (.charAt s i))))\n                    (repeat (- len-1 i) \"0\"))))))"},
       "linear-nl?" {:type "defn-",
                     :key "linear-nl?",
                     :lines [166 169],
                     :filename "pretty_writer.clj",
                     :source "(defn- linear-nl? [this lb section]\n;  (prlabel lnl? @(:done-nl lb) (tokens-fit? this section))\n  (or @(:done-nl lb)\n      (not (tokens-fit? this section))))"},
       "brackets" {:type "defn-",
                   :key "brackets",
                   :lines [174 179],
                   :filename "dispatch.clj",
                   :source "(defn- brackets\n  \"Figure out which kind of brackets to use\"\n  [form]\n  (if (vector? form)\n    [\"[\" \"]\"]\n    [\"(\" \")\"]))"},
       "iterate-list-of-sublists" {:type "defn-",
                                   :key "iterate-list-of-sublists",
                                   :lines [911 930],
                                   :filename "cl_format.clj",
                                   :source "(defn- iterate-list-of-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        [arg-list navigator] (next-arg navigator)]\n    (loop [count 0\n           arg-list arg-list]\n      (if (or (and (empty? arg-list)\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format \n                           clause \n                           (init-navigator (first arg-list))\n                           (init-navigator (next arg-list)))]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) (next arg-list))))))))"},
       "float-parts-base" {:type "defn-",
                           :key "float-parts-base",
                           :lines [542 554],
                           :filename "cl_format.clj",
                           :source "(defn- float-parts-base\n  \"Produce string parts for the mantissa (normalized 1-9) and exponent\"\n  [^Object f]\n  (let [^String s (.toLowerCase (.toString f))\n        exploc (.indexOf s (int \\e))\n        dotloc (.indexOf s (int \\.))]\n    (if (neg? exploc)\n      (if (neg? dotloc)\n        [s (str (dec (count s)))]\n        [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))])\n      (if (neg? dotloc)\n        [(subs s 0 exploc) (subs s (inc exploc))]\n        [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))]))))"},
       "pprint-logical-block" {:type "defmacro",
                               :key "pprint-logical-block",
                               :lines [302 327],
                               :filename "pprint_base.clj",
                               :source "(defmacro pprint-logical-block \n  \"Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.\"\n  {:added \"1.2\", :arglists '[[options* body]]}\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (#'clojure.pprint/level-exceeded) \n           (.write ^java.io.Writer *out* \"#\")\n           (do \n             (push-thread-bindings {#'clojure.pprint/*current-level*\n                                    (inc (var-get #'clojure.pprint/*current-level*))\n                                    #'clojure.pprint/*current-length* 0})\n             (try  \n              (#'clojure.pprint/start-block *out*\n                           ~(:prefix options) ~(:per-line-prefix options) ~(:suffix options))\n              ~@body\n              (#'clojure.pprint/end-block *out*)\n              (finally \n               (pop-thread-bindings)))))\n         nil)))"},
       "tok :buffer-blob" {:type "defmethod",
                           :key "tok :buffer-blob",
                           :lines [248 249],
                           :filename "pretty_writer.clj",
                           :source "(defmethod tok :buffer-blob [token]\n  (str \\\" (:data token) (:trailing-white-space token) \\\"))"},
       "print-table" {:type "defn",
                      :key "print-table",
                      :lines [11 35],
                      :filename "print_table.clj",
                      :source "(defn print-table\n  \"Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n  {:added \"1.3\"}\n  ([ks rows]\n     (when (seq rows)\n       (let [widths (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n             spacers (map #(apply str (repeat % \"-\")) widths)\n             fmts (map #(str \"%\" % \"s\") widths)\n             fmt-row (fn [leader divider trailer row]\n                       (str leader\n                            (apply str (interpose divider\n                                                  (for [[col fmt] (map vector (map #(get row %) ks) fmts)]\n                                                    (format fmt (str col)))))\n                            trailer))]\n         (println)\n         (println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n         (println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n         (doseq [row rows]\n           (println (fmt-row \"| \" \" | \" \" |\" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))"},
       "tok :nl-t" {:type "defmethod",
                    :key "tok :nl-t",
                    :lines [246 247],
                    :filename "pretty_writer.clj",
                    :source "(defmethod tok :nl-t [token]\n  (:type token))"},
       "c-write-char" {:type "defn-",
                       :key "c-write-char",
                       :lines [47 53],
                       :filename "column_writer.clj",
                       :source "(defn- c-write-char [^Writer this ^Integer c]\n  (dosync (if (= c (int \\newline))\n\t    (do\n              (set-field this :cur 0)\n              (set-field this :line (inc (get-field this :line))))\n\t    (set-field this :cur (inc (get-field this :cur)))))\n  (.write ^Writer (get-field this :base) c))"},
       "old-roman-table" {:type "def",
                          :key "old-roman-table",
                          :lines [439 444],
                          :filename "cl_format.clj",
                          :source "(def ^{:private true}\n     old-roman-table\n     [[ \"I\" \"II\" \"III\" \"IIII\" \"V\" \"VI\" \"VII\" \"VIII\" \"VIIII\"]\n      [ \"X\" \"XX\" \"XXX\" \"XXXX\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"LXXXX\"]\n      [ \"C\" \"CC\" \"CCC\" \"CCCC\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"DCCCC\"]\n      [ \"M\" \"MM\" \"MMM\"]])"},
       "split-at-newline" {:type "defn-",
                           :key "split-at-newline",
                           :lines [239 241],
                           :filename "pretty_writer.clj",
                           :source "(defn- split-at-newline [tokens]\n  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]\n    [pre (seq (drop (count pre) tokens))]))"},
       "flag-defs" {:type "def",
                    :key "flag-defs",
                    :lines [1654 1655],
                    :filename "cl_format.clj",
                    :source "(def ^{:private true}\n     flag-defs { \\: :colon, \\@ :at })"},
       "special-radix-markers" {:type "def",
                                :key "special-radix-markers",
                                :lines [165 166],
                                :filename "cl_format.clj",
                                :source "(def ^{:private true}\n     special-radix-markers {2 \"#b\" 8 \"#o\", 16 \"#x\"})"},
       "english-scale-numbers" {:type "def",
                                :key "english-scale-numbers",
                                :lines [314 320],
                                :filename "cl_format.clj",
                                :source "(def ^{:private true}\n     english-scale-numbers \n     [\"\" \"thousand\" \"million\" \"billion\" \"trillion\" \"quadrillion\" \"quintillion\" \n      \"sextillion\" \"septillion\" \"octillion\" \"nonillion\" \"decillion\" \n      \"undecillion\" \"duodecillion\" \"tredecillion\" \"quattuordecillion\" \n      \"quindecillion\" \"sexdecillion\" \"septendecillion\" \n      \"octodecillion\" \"novemdecillion\" \"vigintillion\"])"},
       "formatter" {:type "defmacro",
                    :key "formatter",
                    :lines [1915 1933],
                    :filename "cl_format.clj",
                    :source "(defmacro formatter\n  \"Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning \noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.\"\n  {:added \"1.2\"}\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'cached-compile))\n         my-e-f# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'execute-format))\n         my-i-n# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'init-navigator))\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))"},
       "needs-pretty" {:type "defn-",
                       :key "needs-pretty",
                       :lines [1865 1876],
                       :filename "cl_format.clj",
                       :source "(defn- needs-pretty \n  \"determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing\"\n  [format]\n  (loop [format format]\n    (if (empty? format)\n      false\n      (if (or (:pretty (:flags (:def (first format))))\n              (some needs-pretty (first (:clauses (:params (first format)))))\n              (some needs-pretty (first (:else (:params (first format))))))\n        true\n        (recur (next format))))))"},
       "get-sub-section" {:type "defn-",
                          :key "get-sub-section",
                          :lines [209 215],
                          :filename "pretty_writer.clj",
                          :source "(defn- get-sub-section [buffer]\n  (let [nl (first buffer) \n        lb (:logical-block nl)\n        section (seq (take-while #(let [nl-lb (:logical-block %)]\n                                    (not (and (nl-t? %) (or (= nl-lb lb) (ancestor? nl-lb lb)))))\n                            (next buffer)))]\n    section))"},
       "pprint-map" {:type "defn-",
                     :key "pprint-map",
                     :lines [94 107],
                     :filename "dispatch.clj",
                     :source "(defn- pprint-map [amap]\n  (pprint-logical-block :prefix \"{\" :suffix \"}\"\n    (print-length-loop [aseq (seq amap)]\n      (when aseq\n\t(pprint-logical-block \n          (write-out (ffirst aseq))\n          (.write ^java.io.Writer *out* \" \")\n          (pprint-newline :linear)\n          (set! *current-length* 0)     ; always print both parts of the [k v] pair\n          (write-out (fnext (first aseq))))\n        (when (next aseq)\n          (.write ^java.io.Writer *out* \", \")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))"},
       "pll-mod-body" {:type "defn-",
                       :key "pll-mod-body",
                       :lines [380 389],
                       :filename "pprint_base.clj",
                       :source "(defn- pll-mod-body [var-sym body]\n  (letfn [(inner [form]\n                 (if (seq? form)\n                   (let [form (macroexpand form)] \n                     (condp = (first form)\n                       'loop* form\n                       'recur (concat `(recur (inc ~var-sym)) (rest form))\n                       (walk inner identity form)))\n                   form))]\n    (walk inner identity body)))"},
       "english-ordinal-tens" {:type "def",
                               :key "english-ordinal-tens",
                               :lines [305 308],
                               :filename "cl_format.clj",
                               :source "(def ^{:private true}\n     english-ordinal-tens\n     [\"\" \"\" \"twentieth\" \"thirtieth\" \"fortieth\" \"fiftieth\"\n      \"sixtieth\" \"seventieth\" \"eightieth\" \"ninetieth\"])"},
       "convert-ratio" {:type "defn-",
                        :key "convert-ratio",
                        :lines [655 668],
                        :filename "cl_format.clj",
                        :source "(defn- convert-ratio [x]\n  (if (ratio? x)\n    ;; Usually convert to a double, only resorting to the slower\n    ;; bigdec conversion if the result does not fit within the range\n    ;; of a double.\n    (let [d (double x)]\n      (if (== d 0.0)\n        (if (not= x 0)\n          (bigdec x)\n          d)\n        (if (or (== d Double/POSITIVE_INFINITY) (== d Double/NEGATIVE_INFINITY))\n          (bigdec x)\n          d)))\n    x))"},
       "plain-character" {:type "defn-",
                          :key "plain-character",
                          :lines [512 515],
                          :filename "cl_format.clj",
                          :source "(defn- plain-character [params navigator offsets]\n  (let [[char navigator] (next-arg navigator)]\n    (print char)\n    navigator))"},
       "map-ref-type" {:type "defn-",
                       :key "map-ref-type",
                       :lines [115 120],
                       :filename "dispatch.clj",
                       :source "(defn- map-ref-type \n  \"Map ugly type names to something simpler\"\n  [name]\n  (or (when-let [match (re-find #\"^[^$]+\\$[^$]+\" name)]\n        (type-map match))\n      name))"},
       "ancestor?" {:type "defn-",
                    :key "ancestor?",
                    :lines [68 73],
                    :filename "pretty_writer.clj",
                    :source "(defn- ancestor? [parent child]\n  (loop [child (:parent child)]\n    (cond \n     (nil? child) false\n     (identical? parent child) true\n     :else (recur (:parent child)))))"},
       "new-roman-table" {:type "def",
                          :key "new-roman-table",
                          :lines [446 451],
                          :filename "cl_format.clj",
                          :source "(def ^{:private true}\n     new-roman-table\n     [[ \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n      [ \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n      [ \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n      [ \"M\" \"MM\" \"MMM\"]])"},
       "iterate-main-sublists" {:type "defn-",
                                :key "iterate-main-sublists",
                                :lines [958 975],
                                :filename "cl_format.clj",
                                :source "(defn- iterate-main-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        ]\n    (loop [count 0\n           navigator navigator]\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [[sublist navigator] (next-arg-or-nil navigator)\n              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) navigator)))))))"},
       "pretty-character" {:type "defn-",
                           :key "pretty-character",
                           :lines [490 502],
                           :filename "cl_format.clj",
                           :source "(defn- pretty-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)\n        as-int (int c)\n        base-char (bit-and as-int 127)\n        meta (bit-and as-int 128)\n        special (get special-chars base-char)]\n    (if (> meta 0) (print \"Meta-\"))\n    (print (cond\n            special special\n            (< base-char 32) (str \"Control-\" (char (+ base-char 64)))\n            (= base-char 127) \"Control-?\"\n            :else (char base-char)))\n    navigator))"},
       "format-roman" {:type "defn-",
                       :key "format-roman",
                       :lines [453 475],
                       :filename "cl_format.clj",
                       :source "(defn- format-roman\n  \"Format a roman numeral using the specified look-up table\"\n  [table params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (and (number? arg) (> arg 0) (< arg 4000))\n      (let [digits (remainders 10 arg)]\n        (loop [acc []\n               pos (dec (count digits))\n               digits digits]\n          (if (empty? digits)\n            (print (apply str acc))\n            (let [digit (first digits)]\n              (recur (if (= 0 digit) \n                       acc \n                       (conj acc (nth (nth table pos) (dec digit))))\n                     (dec pos)\n                     (next digits))))))\n      (format-integer ;; for anything <= 0 or > 3999, we fall back on ~D\n           10\n           { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n           (init-navigator [arg])\n           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))\n    navigator))"},
       "float-parts" {:type "defn-",
                      :key "float-parts",
                      :lines [557 567],
                      :filename "cl_format.clj",
                      :source "(defn- float-parts\n  \"Take care of leading and trailing zeros in decomposed floats\"\n  [f]\n  (let [[m ^String e] (float-parts-base f)\n        m1 (rtrim m \\0)\n        m2 (ltrim m1 \\0)\n        delta (- (count m1) (count m2))\n        ^String e (if (and (pos? (count e)) (= (nth e 0) \\+)) (subs e 1) e)]\n    (if (empty? m2)\n      [\"0\" 0]\n      [m2 (- (Integer/valueOf e) delta)])))"},
       "*print-pprint-dispatch*" {:type "defonce",
                                  :key "*print-pprint-dispatch*",
                                  :lines [34 38],
                                  :filename "pprint_base.clj",
                                  :source "(defonce ^:dynamic ; If folks have added stuff here, don't overwrite\n ^{:doc \"The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch\nto modify.\",\n   :added \"1.2\"}\n *print-pprint-dispatch* nil)"},
       "check-enumerated-arg" {:type "defn-",
                               :key "check-enumerated-arg",
                               :lines [292 297],
                               :filename "pprint_base.clj",
                               :source "(defn- check-enumerated-arg [arg choices]\n  (if-not (choices arg)\n          (throw\n           (IllegalArgumentException.\n            ;; TODO clean up choices string\n            (str \"Bad argument: \" arg \". It must be one of \" choices)))))"},
       "with-pretty-writer" {:type "defmacro",
                             :key "with-pretty-writer",
                             :lines [160 167],
                             :filename "pprint_base.clj",
                             :source "(defmacro ^{:private true} with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (binding [*out* (if new-writer#\n                      (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                      base-writer#)]\n       ~@body\n       (.ppflush *out*))))"},
       "buffer-length" {:type "defn-",
                        :key "buffer-length",
                        :lines [77 81],
                        :filename "pretty_writer.clj",
                        :source "(defn- buffer-length [l] \n  (let [l (seq l)]\n    (if l \n      (- (:end-pos (last l)) (:start-pos (first l)))\n      0)))"},
       "round-str" {:type "defn-",
                    :key "round-str",
                    :lines [585 625],
                    :filename "cl_format.clj",
                    :source "(defn- round-str [m e d w]\n  (if (or d w)\n    (let [len (count m)\n          ;; Every formatted floating point number should include at\n          ;; least one decimal digit and a decimal point.\n          w (if w (max 2 w))\n          round-pos (cond\n                     ;; If d was given, that forces the rounding\n                     ;; position, regardless of any width that may\n                     ;; have been specified.\n                     d (+ e d 1)\n                     ;; Otherwise w was specified, so pick round-pos\n                     ;; based upon that.\n                     ;; If e>=0, then abs value of number is >= 1.0,\n                     ;; and e+1 is number of decimal digits before the\n                     ;; decimal point when the number is written\n                     ;; without scientific notation.  Never round the\n                     ;; number before the decimal point.\n                     (>= e 0) (max (inc e) (dec w))\n                     ;; e < 0, so number abs value < 1.0\n                     :else (+ w e))\n          [m1 e1 round-pos len] (if (= round-pos 0) \n                                  [(str \"0\" m) (inc e) 1 (inc len)]\n                                  [m e round-pos len])]\n      (if round-pos\n        (if (neg? round-pos)\n          [\"0\" 0 false]\n          (if (> len round-pos)\n            (let [round-char (nth m1 round-pos)\n                  ^String result (subs m1 0 round-pos)]\n              (if (>= (int round-char) (int \\5))\n                (let [round-up-result (inc-s result)\n                      expanded (> (count round-up-result) (count result))]\n                  [(if expanded\n                     (subs round-up-result 0 (dec (count round-up-result)))\n                     round-up-result)\n                   e1 expanded])\n                [result e1 false]))\n            [m e false]))\n        [m e false]))\n    [m e false]))"},
       "set-pprint-dispatch" {:type "defn",
                              :key "set-pprint-dispatch",
                              :lines [260 272],
                              :filename "pprint_base.clj",
                              :source "(defn set-pprint-dispatch  \n  \"Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.\"\n  {:added \"1.2\"}\n  [function]\n  (let [old-meta (meta #'*print-pprint-dispatch*)]\n    (alter-var-root #'*print-pprint-dispatch* (constantly function))\n    (alter-meta! #'*print-pprint-dispatch* (constantly old-meta)))\n  nil)"},
       "*current-length*" {:type "def",
                           :key "*current-length*",
                           :lines [101 101],
                           :filename "pprint_base.clj",
                           :source "(def ^:dynamic ^{ :private true } *current-length* nil)"},
       "tok :default" {:type "defmethod",
                       :key "tok :default",
                       :lines [250 251],
                       :filename "pretty_writer.clj",
                       :source "(defmethod tok :default [token]\n  (:type-tag token))"},
       "pprint-array" {:type "def",
                       :key "pprint-array",
                       :lines [91 91],
                       :filename "dispatch.clj",
                       :source "(def ^{:private true} pprint-array (formatter-out \"~<[~;~@{~w~^, ~:_~}~;]~:>\"))"},
       "check-flags" {:type "defn-",
                      :key "check-flags",
                      :lines [1672 1683],
                      :filename "cl_format.clj",
                      :source "(defn- check-flags [def flags]\n  (let [allowed (:flags def)]\n    (if (and (not (:at allowed)) (:at flags))\n      (format-error (str \"\\\"@\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:at flags) 1)))\n    (if (and (not (:colon allowed)) (:colon flags))\n      (format-error (str \"\\\":\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:colon flags) 1)))\n    (if (and (not (:both allowed)) (:at flags) (:colon flags))\n      (format-error (str \"Cannot combine \\\"@\\\" and \\\":\\\" flags for format directive \\\"\" \n                         (:directive def) \"\\\"\")\n                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))"},
       "format-old-roman" {:type "defn-",
                           :key "format-old-roman",
                           :lines [477 478],
                           :filename "cl_format.clj",
                           :source "(defn- format-old-roman [params navigator offsets]\n  (format-roman old-roman-table params navigator offsets))"},
       "*print-circle*" {:type "def",
                         :key "*print-circle*",
                         :lines [61 64],
                         :filename "pprint_base.clj",
                         :source "(def ^:dynamic\n ^{:private true,\n   :doc \"Mark circular structures (N.B. This is not yet used)\"}\n *print-circle* nil)"},
       "write-buffered-output" {:type "defn-",
                                :key "write-buffered-output",
                                :lines [308 313],
                                :filename "pretty_writer.clj",
                                :source "(defn- write-buffered-output [^Writer this]\n  (write-line this)\n  (if-let [buf (getf :buffer)]\n    (do\n      (write-tokens this buf true)\n      (setf :buffer []))))"},
       "format-new-roman" {:type "defn-",
                           :key "format-new-roman",
                           :lines [480 481],
                           :filename "cl_format.clj",
                           :source "(defn- format-new-roman [params navigator offsets]\n  (format-roman new-roman-table params navigator offsets))"},
       "make-pretty-writer" {:type "defn-",
                             :key "make-pretty-writer",
                             :lines [155 158],
                             :filename "pprint_base.clj",
                             :source "(defn- make-pretty-writer \n  \"Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width\"\n  [base-writer right-margin miser-width]\n  (pretty-writer base-writer right-margin miser-width))"},
       "compiled-directive" {:type "defstruct",
                             :key "compiled-directive",
                             :lines [123 124],
                             :filename "cl_format.clj",
                             :source "(defstruct ^{:private true}\n  compiled-directive :func :def :params :offset)"},
       "emit-nl" {:type "defn-",
                  :key "emit-nl",
                  :lines [227 237],
                  :filename "pretty_writer.clj",
                  :source "(defn- emit-nl [^Writer this nl]\n  (.write (getf :base) (pp-newline))\n  (dosync (setf :trailing-white-space nil))\n  (let [lb (:logical-block nl)\n        ^String prefix (:per-line-prefix lb)] \n    (if prefix \n      (.write (getf :base) prefix))\n    (let [^String istr (apply str (repeat (- @(:indent lb) (count prefix))\n\t\t\t\t\t  \\space))] \n      (.write (getf :base) istr))\n    (update-nl-state lb)))"},
       "code-dispatch" {:type "defmulti",
                        :key "code-dispatch",
                        :lines [448 452],
                        :filename "dispatch.clj",
                        :source "(defmulti \n  code-dispatch\n  \"The pretty print dispatch function for pretty printing Clojure code.\"\n  {:added \"1.2\" :arglists '[[object]]} \n  class)"},
       "format-ordinal-english" {:type "defn-",
                                 :key "format-ordinal-english",
                                 :lines [402 432],
                                 :filename "cl_format.clj",
                                 :source "(defn- format-ordinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zeroth\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal (drop-last parts))\n                head-str (add-english-scales parts-strs 1)\n                tail-str (format-simple-ordinal (last parts))]\n            (print (str (if (neg? arg) \"minus \") \n                        (cond \n                         (and (not (empty? head-str)) (not (empty? tail-str))) \n                         (str head-str \", \" tail-str)\n                         \n                         (not (empty? head-str)) (str head-str \"th\")\n                         :else tail-str))))\n          (do (format-integer ;; for numbers > 10^63, we fall back on ~D\n               10\n               { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n               (init-navigator [arg])\n               { :mincol 0, :padchar 0, :commachar 0 :commainterval 0})\n              (let [low-two-digits (rem arg 100)\n                    not-teens (or (< 11 low-two-digits) (> 19 low-two-digits))\n                    low-digit (rem low-two-digits 10)]\n                (print (cond \n                        (and (== low-digit 1) not-teens) \"st\"\n                        (and (== low-digit 2) not-teens) \"nd\"\n                        (and (== low-digit 3) not-teens) \"rd\"\n                        :else \"th\")))))))\n    navigator))"},
       "write" {:type "defn",
                :key "write",
                :lines [197 238],
                :filename "pprint_base.clj",
                :source "(defn write \n  \"Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n\"\n  {:added \"1.2\"}\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    (binding-map (table-ize write-option-table options) \n      (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) \n        (let [optval (if (contains? options :stream) \n                       (:stream options)\n                       true) \n              base-writer (condp = optval\n                            nil (java.io.StringWriter.)\n                            true *out*\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n              (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (nil? optval) \n            (.toString ^java.io.StringWriter base-writer)))))))"},
       "miser-nl?" {:type "defn-",
                    :key "miser-nl?",
                    :lines [171 176],
                    :filename "pretty_writer.clj",
                    :source "(defn- miser-nl? [^Writer this lb section]\n  (let [miser-width (get-miser-width this)\n        maxcol (get-max-column (getf :base))]\n    (and miser-width maxcol\n         (>= @(:start-col lb) (- maxcol miser-width))\n         (linear-nl? this lb section))))"},
       "pprint-set" {:type "def",
                     :key "pprint-set",
                     :lines [109 109],
                     :filename "dispatch.clj",
                     :source "(def ^{:private true} pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))"},
       "translate-param" {:type "defn-",
                          :key "translate-param",
                          :lines [1642 1652],
                          :filename "cl_format.clj",
                          :source "(defn- translate-param\n  \"Translate the string representation of a param to the internalized\n                                      representation\"\n  [[^String p offset]]\n  [(cond \n    (= (.length p) 0) nil\n    (and (= (.length p) 1) (contains? #{\\v \\V} (nth p 0))) :parameter-from-args\n    (and (= (.length p) 1) (= \\# (nth p 0))) :remaining-arg-count\n    (and (= (.length p) 2) (= \\' (nth p 0))) (nth p 1)\n    true (new Integer p))\n   offset])"},
       "formatter-out" {:type "defmacro",
                        :key "formatter-out",
                        :lines [1935 1948],
                        :filename "cl_format.clj",
                        :source "(defmacro formatter-out\n  \"Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.\"\n  {:added \"1.2\"}\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (#'clojure.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (#'clojure.pprint/init-navigator args#)]\n         (#'clojure.pprint/execute-format cf# navigator#)))))"},
       "p-write-char" {:type "defn-",
                       :key "p-write-char",
                       :lines [351 362],
                       :filename "pretty_writer.clj",
                       :source "(defn- p-write-char [^Writer this ^Integer c]\n  (if (= (getf :mode) :writing)\n    (do \n      (write-white-space this)\n      (.write (getf :base) c))\n    (if (= c \\newline)\n      (write-initial-lines this \"\\n\")\n      (let [oldpos (getf :pos)\n            newpos (inc oldpos)]\n        (dosync\n         (setf :pos newpos)\n         (add-to-buffer this (make-buffer-blob (str (char c)) nil oldpos newpos)))))))"},
       "write-line" {:type "defn-",
                     :key "write-line",
                     :lines [287 296],
                     :filename "pretty_writer.clj",
                     :source "(defn- write-line [^Writer this]\n  (dosync\n   (loop [buffer (getf :buffer)]\n;;     (prlabel wl1 (toks buffer))\n     (setf :buffer (into [] buffer))\n     (if (not (tokens-fit? this buffer))\n       (let [new-buffer (write-token-string this buffer)]\n;;          (prlabel wl new-buffer)\n         (if-not (identical? buffer new-buffer)\n                 (recur new-buffer)))))))"},
       "get-line" {:type "defn-",
                   :key "get-line",
                   :lines [34 35],
                   :filename "column_writer.clj",
                   :source "(defn- get-line [this]\n  (get-field this :line))"},
       "table-ize" {:type "defn-",
                    :key "table-ize",
                    :lines [146 149],
                    :filename "pprint_base.clj",
                    :source "(defn- table-ize [t m] \n  (apply hash-map (mapcat \n                   #(when-let [v (get t (key %))] [(find-var v) (val %)]) \n                   m)))"},
       "add-english-scales" {:type "defn-",
                             :key "add-english-scales",
                             :lines [340 361],
                             :filename "cl_format.clj",
                             :source "(defn- add-english-scales\n  \"Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\noffset is a factor of 10^3 to multiply by\"\n  [parts offset]\n  (let [cnt (count parts)]\n    (loop [acc []\n           pos (dec cnt)\n           this (first parts)\n           remainder (next parts)]\n      (if (nil? remainder)\n        (str (apply str (interpose \", \" acc))\n             (if (and (not (empty? this)) (not (empty? acc))) \", \")\n             this\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\n               (str \" \" (nth english-scale-numbers (+ pos offset)))))\n        (recur \n         (if (empty? this)\n           acc\n           (conj acc (str this \" \" (nth english-scale-numbers (+ pos offset)))))\n         (dec pos)\n         (first remainder)\n         (next remainder))))))"},
       "extract-param" {:type "defn-",
                        :key "extract-param",
                        :lines [1624 1636],
                        :filename "cl_format.clj",
                        :source "(defn- extract-param [[s offset saw-comma]]\n  (let [m (re-matcher param-pattern s)\n        param (re-find m)]\n    (if param\n      (let [token-str (first (re-groups m))\n            remainder (subs s (.end m))\n            new-offset (+ offset (.end m))]\n        (if (not (= \\, (nth remainder 0)))\n          [ [token-str offset] [remainder new-offset false]]\n          [ [token-str offset] [(subs remainder 1) (inc new-offset) true]]))\n      (if saw-comma \n        (format-error \"Badly formed parameters in format directive\" offset)\n        [ nil [s offset]]))))"},
       "pprint-vector" {:type "defn-",
                        :key "pprint-vector",
                        :lines [81 89],
                        :filename "dispatch.clj",
                        :source "(defn- pprint-vector [avec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [aseq (seq avec)]\n      (when aseq\n\t(write-out (first aseq))\n\t(when (next aseq)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next aseq)))))))"},
       "separator?" {:type "defn-",
                     :key "separator?",
                     :lines [1739 1739],
                     :filename "cl_format.clj",
                     :source "(defn- separator? [this] (:separator (:bracket-info (:def this))))"},
       "rtrim" {:type "defn-",
                :key "rtrim",
                :lines [64 73],
                :filename "utilities.clj",
                :source "(defn- rtrim [s c]\n  \"Trim all instances of c from the end of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s (dec (count s))) c))\n      (loop [n (dec len)]\n        (cond \n         (neg? n) \"\"\n         (not (= (nth s n) c)) (subs s 0 (inc n))\n         true (recur (dec n))))\n      s)))"},
       "get-writer" {:type "defn-",
                     :key "get-writer",
                     :lines [44 45],
                     :filename "column_writer.clj",
                     :source "(defn- get-writer [this]\n  (get-field this :base))"},
       "pprint-ns-reference" {:type "defn-",
                              :key "pprint-ns-reference",
                              :lines [181 213],
                              :filename "dispatch.clj",
                              :source "(defn- pprint-ns-reference\n  \"Pretty print a single reference (import, use, etc.) from a namespace decl\"\n  [reference]\n  (if (sequential? reference)\n    (let [[start end] (brackets reference)\n          [keyw & args] reference]\n      (pprint-logical-block :prefix start :suffix end\n        ((formatter-out \"~w~:i\") keyw)\n        (loop [args args]\n          (when (seq args)\n            ((formatter-out \" \"))\n            (let [arg (first args)]\n              (if (sequential? arg)\n                (let [[start end] (brackets arg)]\n                  (pprint-logical-block :prefix start :suffix end\n                    (if (and (= (count arg) 3) (keyword? (second arg)))\n                      (let [[ns kw lis] arg]\n                        ((formatter-out \"~w ~w \") ns kw)\n                        (if (sequential? lis)\n                          ((formatter-out (if (vector? lis)\n                                            \"~<[~;~@{~w~^ ~:_~}~;]~:>\"\n                                            \"~<(~;~@{~w~^ ~:_~}~;)~:>\"))\n                           lis)\n                          (write-out lis)))\n                      (apply (formatter-out \"~w ~:i~@{~w~^ ~:_~}\") arg)))\n                  (when (next args)\n                    ((formatter-out \"~_\"))))\n                (do\n                  (write-out arg)\n                  (when (next args)\n                    ((formatter-out \"~:_\"))))))\n            (recur (next args))))))\n    (write-out reference)))"},
       "pretty-writer" {:type "defn-",
                        :key "pretty-writer",
                        :lines [370 423],
                        :filename "pretty_writer.clj",
                        :source "(defn- pretty-writer [writer max-columns miser-width]\n  (let [lb (struct logical-block nil nil (ref 0) (ref 0) (ref false) (ref false))\n        fields (ref {:pretty-writer true\n                     :base (column-writer writer max-columns)\n                     :logical-blocks lb \n                     :sections nil\n                     :mode :writing\n                     :buffer []\n                     :buffer-block lb\n                     :buffer-level 1\n                     :miser-width miser-width\n                     :trailing-white-space nil\n                     :pos 0})]\n    (proxy [Writer IDeref PrettyFlush] []\n      (deref [] fields)\n\n      (write \n       ([x]\n          ;;     (prlabel write x (getf :mode))\n          (condp = (class x)\n            String \n            (let [^String s0 (write-initial-lines this x)\n                  ^String s (.replaceFirst s0 \"\\\\s+$\" \"\")\n                  white-space (.substring s0 (count s))\n                  mode (getf :mode)]\n              (dosync\n               (if (= mode :writing)\n                 (do\n                   (write-white-space this)\n                   (.write (getf :base) s)\n                   (setf :trailing-white-space white-space))\n                 (let [oldpos (getf :pos)\n                       newpos (+ oldpos (count s0))]\n                   (setf :pos newpos)\n                   (add-to-buffer this (make-buffer-blob s white-space oldpos newpos))))))\n\n            Integer\n            (p-write-char this x)\n            Long\n            (p-write-char this x))))\n\n      (ppflush []\n             (if (= (getf :mode) :buffering)\n               (dosync\n                (write-tokens this (getf :buffer) true)\n                (setf :buffer []))\n               (write-white-space this)))\n\n      (flush []\n             (.ppflush this)\n             (.flush (getf :base)))\n\n      (close []\n             (.flush this)))))"},
       "two-forms" {:type "defn-",
                    :key "two-forms",
                    :lines [402 407],
                    :filename "dispatch.clj",
                    :source "(defn- two-forms [amap]\n  (into {} \n        (mapcat \n         identity \n         (for [x amap] \n           [x [(symbol (name (first x))) (second x)]]))))"},
       "pprint-ideref" {:type "defn-",
                        :key "pprint-ideref",
                        :lines [122 136],
                        :filename "dispatch.clj",
                        :source "(defn- pprint-ideref [o]\n  (let [prefix (format \"#<%s@%x%s: \"\n                       (map-ref-type (.getSimpleName (class o)))\n                       (System/identityHashCode o)\n                       (if (and (instance? clojure.lang.Agent o)\n                                (agent-error o))\n                         \" FAILED\"\n                         \"\"))]\n    (pprint-logical-block  :prefix prefix :suffix \">\"\n                           (pprint-indent :block (-> (count prefix) (- 2) -))\n                           (pprint-newline :linear)\n                           (write-out (cond \n                                       (and (future? o) (not (future-done? o))) :pending\n                                       (and (instance? clojure.lang.IPending o) (not (.isRealized o))) :not-delivered\n                                       :else @o)))))"},
       "iterate-sublist" {:type "defn-",
                          :key "iterate-sublist",
                          :lines [886 907],
                          :filename "cl_format.clj",
                          :source "(defn- iterate-sublist [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        [arg-list navigator] (next-arg navigator)\n        args (init-navigator arg-list)]\n    (loop [count 0\n           args args\n           last-pos (num -1)]\n      (if (and (not max-count) (= (:pos args) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (RuntimeException. \"%{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest args))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause args (:base-args params))] \n          (if (= :up-arrow (first iter-result))\n            navigator\n            (recur (inc count) iter-result (:pos args))))))))"},
       "compile-directive" {:type "defn-",
                            :key "compile-directive",
                            :lines [1715 1733],
                            :filename "cl_format.clj",
                            :source "(defn- compile-directive [s offset]\n  (let [[raw-params [rest offset]] (extract-params s offset)\n        [_ [rest offset flags]] (extract-flags rest offset)\n        directive (first rest)\n        def (get directive-table (Character/toUpperCase ^Character directive))\n        params (if def (map-params def (map translate-param raw-params) flags offset))]\n    (if (not directive)\n      (format-error \"Format string ended in the middle of a directive\" offset))\n    (if (not def)\n      (format-error (str \"Directive \\\"\" directive \"\\\" is undefined\") offset))\n    [(struct compiled-directive ((:generator-fn def) params offset) def params offset)\n     (let [remainder (subs rest 1) \n           offset (inc offset)\n           trim? (and (= \\newline (:directive def))\n                      (not (:colon params)))\n           trim-count (if trim? (prefix-count remainder [\\space \\tab]) 0)\n           remainder (subs remainder trim-count)\n           offset (+ offset trim-count)]\n       [remainder offset])]))"},
       "get-format-arg" {:type "defn-",
                         :key "get-format-arg",
                         :lines [103 108],
                         :filename "cl_format.clj",
                         :source "(defn- get-format-arg [navigator]\n  (let [[raw-format navigator] (next-arg navigator)\n        compiled-format (if (instance? String raw-format) \n                               (compile-format raw-format)\n                               raw-format)]\n    [compiled-format navigator]))"},
       "consume-while" {:type "defn-",
                        :key "consume-while",
                        :lines [45 51],
                        :filename "utilities.clj",
                        :source "(defn- consume-while [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result continue new-context] (apply func [context])]\n      (if (not continue)\n        [acc context]\n      (recur new-context (conj acc result))))))"},
       "init-cap-writer" {:type "defn-",
                          :key "init-cap-writer",
                          :lines [1160 1192],
                          :filename "cl_format.clj",
                          :source "(defn- init-cap-writer\n  \"Returns a proxy that wraps writer, capitalizing the first word\"\n  [^java.io.Writer writer]\n  (let [capped (ref false)] \n    (proxy [java.io.Writer] []\n      (close [] (.close writer))\n      (flush [] (.flush writer))\n      (write ([^chars cbuf ^Integer off ^Integer len] \n                (.write writer cbuf off len))\n             ([x]\n                (condp = (class x)\n                 String \n                 (let [s (.toLowerCase ^String x)]\n                   (if (not @capped) \n                     (let [m (re-matcher #\"\\S\" s)\n                           match (re-find m)\n                           offset (and match (.start m))]\n                       (if offset\n                         (do (.write writer \n                                   (str (subs s 0 offset) \n                                        (Character/toUpperCase ^Character (nth s offset))\n                                        (.toLowerCase ^String (subs s (inc offset)))))\n                           (dosync (ref-set capped true)))\n                         (.write writer s))) \n                     (.write writer (.toLowerCase s))))\n\n                 Integer\n                 (let [c ^Character (char x)]\n                   (if (and (not @capped) (Character/isLetter c))\n                     (do\n                       (dosync (ref-set capped true))\n                       (.write writer (int (Character/toUpperCase c))))\n                     (.write writer (int (Character/toLowerCase c)))))))))))"},
       "pprint-code-list" {:type "defn-",
                           :key "pprint-code-list",
                           :lines [435 439],
                           :filename "dispatch.clj",
                           :source "(defn- pprint-code-list [alis]\n  (if-not (pprint-reader-macro alis) \n    (if-let [special-form (*code-table* (first alis))]\n      (special-form alis)\n      (pprint-simple-code-list alis))))"},
       "pprint-simple-code-list" {:type "defn-",
                                  :key "pprint-simple-code-list",
                                  :lines [389 398],
                                  :filename "dispatch.clj",
                                  :source "(defn- pprint-simple-code-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (print-length-loop [alis (seq alis)]\n      (when alis\n\t(write-out (first alis))\n\t(when (next alis)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next alis)))))))"},
       "simple-dispatch" {:type "defmulti",
                          :key "simple-dispatch",
                          :lines [147 151],
                          :filename "dispatch.clj",
                          :source "(defmulti \n  simple-dispatch\n  \"The pretty print dispatch function for simple data structure format.\"\n  {:added \"1.2\" :arglists '[[object]]} \n  class)"},
       "buffer-blob" {:type "deftype",
                      :key "buffer-blob",
                      :lines [84 84],
                      :filename "pretty_writer.clj",
                      :source "(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)"},
       "cl-format" {:type "defn",
                    :key "cl-format",
                    :lines [27 64],
                    :filename "cl_format.clj",
                    :source "(defn cl-format \n  \"An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It \nsupports sophisticated formatting of structured data.\n\nWriter is an instance of java.io.Writer, true to output to *out* or nil to output \nto a string, format-in is the format control string and the remaining arguments \nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives' \ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format \nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\" \n                   (count results) results))\n\nPrints to *out*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \\\"Common Lisp the \nLanguage, 2nd edition\\\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) \nand in the Common Lisp HyperSpec at \nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\n\"\n  {:added \"1.2\",\n   :see-also [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\" \n               \"Common Lisp the Language\"]\n              [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n               \"Common Lisp HyperSpec\"]]}\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))"},
       "end-block-t" {:type "deftype",
                      :key "end-block-t",
                      :lines [91 91],
                      :filename "pretty_writer.clj",
                      :source "(deftype end-block-t :logical-block :start-pos :end-pos)"},
       "insert-decimal" {:type "defn-",
                         :key "insert-decimal",
                         :lines [637 643],
                         :filename "cl_format.clj",
                         :source "(defn- insert-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m e]\n  (if (neg? e)\n    (str \".\" m)\n    (let [loc (inc e)]\n      (str (subs m 0 loc) \".\" (subs m loc)))))"},
       "tokens-fit?" {:type "defn-",
                      :key "tokens-fit?",
                      :lines [159 164],
                      :filename "pretty_writer.clj",
                      :source "(defn- tokens-fit? [^Writer this tokens]\n;;;  (prlabel tf? (get-column (getf :base) (buffer-length tokens))\n  (let [maxcol (get-max-column (getf :base))]\n    (or \n     (nil? maxcol) \n     (< (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))"},
       "collect-clauses" {:type "defn-",
                          :key "collect-clauses",
                          :lines [1780 1827],
                          :filename "cl_format.clj",
                          :source "(defn- collect-clauses [bracket-info offset remainder]\n  (second\n   (consume\n    (fn [[clause-map saw-else remainder]]\n      (let [[clause [type right-params else-params remainder]] \n            (process-clause bracket-info offset remainder)]\n        (cond\n         (= type :right-bracket)\n         [nil [(merge-with concat clause-map \n                           {(if saw-else :else :clauses) [clause] \n                            :right-params right-params})\n               remainder]]\n\n         (= type :else)\n         (cond\n          (:else clause-map)\n          (format-error \"Two else clauses (\\\"~:;\\\") inside bracket construction.\" offset)\n         \n          (not (:else bracket-info))\n          (format-error \"An else clause (\\\"~:;\\\") is in a bracket type that doesn't support it.\" \n                        offset)\n\n          (and (= :first (:else bracket-info)) (seq (:clauses clause-map)))\n          (format-error\n           \"The else clause (\\\"~:;\\\") is only allowed in the first position for this directive.\" \n           offset)\n         \n          true         ; if the ~:; is in the last position, the else clause\n                                        ; is next, this was a regular clause\n          (if (= :first (:else bracket-info))\n            [true [(merge-with concat clause-map { :else [clause] :else-params else-params})\n                   false remainder]]\n            [true [(merge-with concat clause-map { :clauses [clause] })\n                   true remainder]]))\n\n         (= type :separator)\n         (cond\n          saw-else\n          (format-error \"A plain clause (with \\\"~;\\\") follows an else clause (\\\"~:;\\\") inside bracket construction.\" offset)\n         \n          (not (:allows-separator bracket-info))\n          (format-error \"A separator (\\\"~;\\\") is in a bracket type that doesn't support it.\" \n                        offset)\n         \n          true\n          [true [(merge-with concat clause-map { :clauses [clause] })\n                 false remainder]]))))\n    [{ :clauses [] } false remainder])))"},
       "right-bracket" {:type "defn-",
                        :key "right-bracket",
                        :lines [1738 1738],
                        :filename "cl_format.clj",
                        :source "(defn- right-bracket [this] (:right (:bracket-info (:def this))))"},
       "upcase-writer" {:type "defn-",
                        :key "upcase-writer",
                        :lines [1090 1106],
                        :filename "cl_format.clj",
                        :source "(defn- upcase-writer \n  \"Returns a proxy that wraps writer, converting all characters to upper case\"\n  [^java.io.Writer writer]\n  (proxy [java.io.Writer] []\n    (close [] (.close writer))\n    (flush [] (.flush writer))\n    (write ([^chars cbuf ^Integer off ^Integer len] \n              (.write writer cbuf off len))\n           ([x]\n              (condp = (class x)\n\t\tString \n\t\t(let [s ^String x]\n\t\t  (.write writer (.toUpperCase s)))\n\n\t\tInteger\n\t\t(let [c ^Character x]\n\t\t  (.write writer (int (Character/toUpperCase (char c))))))))))"},
       "deftype" {:type "defmacro",
                  :key "deftype",
                  :lines [48 56],
                  :filename "pretty_writer.clj",
                  :source "(defmacro ^{:private true} \n  deftype [type-name & fields]\n  (let [name-str (name type-name)]\n    `(do\n       (defstruct ~type-name :type-tag ~@fields)\n       (alter-meta! #'~type-name assoc :private true)\n       (defn- ~(symbol (str \"make-\" name-str)) \n         [& vals#] (apply struct ~type-name ~(keyword name-str) vals#))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))"},
       "next-arg-or-nil" {:type "defn-",
                          :key "next-arg-or-nil",
                          :lines [96 100],
                          :filename "cl_format.clj",
                          :source "(defn- next-arg-or-nil [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]\n      [nil navigator])))"}},
 :cljs {"nl" {:type "defn-",
              :key "nl",
              :lines [587 590],
              :filename "pprint.cljs",
              :source "(defn- nl [this type]\n  (setf :mode :buffering)\n  (let [pos (getf :pos)]\n    (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos))))"},
        "pprint-defn" {:type "defn-",
                       :key "pprint-defn",
                       :lines [3030 3049],
                       :filename "pprint.cljs",
                       :source "(defn- pprint-defn [alis]\n  (if (next alis)\n    (let [[defn-sym defn-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map stuff] (if (map? (first stuff))\n                             [(first stuff) (next stuff)]\n                             [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") defn-sym defn-name)\n        (if doc-str\n          ((formatter-out \" ~_~w\") doc-str))\n        (if attr-map\n          ((formatter-out \" ~_~w\") attr-map))\n        ;; Note: the multi-defn case will work OK for malformed defns too\n        (cond\n          (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n          :else (multi-defn stuff (or doc-str attr-map)))))\n    (pprint-simple-code-list alis)))"},
        "pprint" {:type "defn",
                  :key "pprint",
                  :lines [812 823],
                  :filename "pprint.cljs",
                  :source "(defn pprint\n  ([object]\n   (let [sb (StringBuffer.)]\n     (binding [*out* (StringBufferWriter. sb)]\n       (pprint object *out*)\n       (*print-fn* (str sb)))))\n  ([object writer]\n   (with-pretty-writer writer\n                       (binding [*print-pretty* true]\n                         (write-out object))\n                       (if (not (= 0 (get-column *out*)))\n                         (-write *out* \\newline)))))"},
        "parse-lb-options" {:type "defn-",
                            :key "parse-lb-options",
                            :lines [42 47],
                            :filename "pprint.clj",
                            :source "(defn- parse-lb-options [opts body]\n  (loop [body body\n         acc []]\n    (if (opts (first body))\n      (recur (drop 2 body) (concat acc (take 2 body)))\n      [(apply hash-map acc) body])))"},
        "conditional-newline" {:type "defn-",
                               :key "conditional-newline",
                               :lines [2165 2170],
                               :filename "pprint.cljs",
                               :source "(defn- conditional-newline [params navigator offsets]\n  (let [kind (if (:colon params)\n               (if (:at params) :mandatory :fill)\n               (if (:at params) :miser :linear))]\n    (pprint-newline kind)\n    navigator))"},
        "*print-lines*" {:type "def",
                         :key "*print-lines*",
                         :lines [641 644],
                         :filename "pprint.cljs",
                         :source "(def ^:dynamic\n^{:private true,\n  :doc \"Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)\"}\n*print-lines* nil)"},
        "pprint-cond" {:type "defn-",
                       :key "pprint-cond",
                       :lines [3086 3104],
                       :filename "pprint.cljs",
                       :source "(defn- pprint-cond [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (write-out (first alis))\n    (when (next alis)\n      (-write *out* \" \")\n      (pprint-newline :linear)\n      (print-length-loop [alis (next alis)]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))))"},
        "english-ordinal-units" {:type "def",
                                 :key "english-ordinal-units",
                                 :lines [1152 1156],
                                 :filename "pprint.cljs",
                                 :source "(def ^{:private true}\n     english-ordinal-units\n     [\"zeroth\" \"first\" \"second\" \"third\" \"fourth\" \"fifth\" \"sixth\" \"seventh\" \"eighth\" \"ninth\"\n      \"tenth\" \"eleventh\" \"twelfth\" \"thirteenth\" \"fourteenth\"\n      \"fifteenth\" \"sixteenth\" \"seventeenth\" \"eighteenth\" \"nineteenth\"])"},
        "*print-right-margin*" {:type "def",
                                :key "*print-right-margin*",
                                :lines [626 631],
                                :filename "pprint.cljs",
                                :source "(def ^:dynamic\n ^{:doc \"Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.\",\n   :added \"1.2\"}\n *print-right-margin* 72)"},
        "capitalize-word-writer" {:type "defn-",
                                  :key "capitalize-word-writer",
                                  :lines [1994 2018],
                                  :filename "pprint.cljs",
                                  :source "(defn- capitalize-word-writer\n  \"Returns a proxy that wraps writer, capitalizing all words\"\n  [writer]\n  (let [last-was-whitespace? (atom true)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n               (.write writer cbuf off len))\n        [this x]\n        (condp = (type x)\n          js/String\n          (let [s x]\n            (-write writer\n                    (capitalize-string (.toLowerCase s) @last-was-whitespace?))\n            (when (pos? (.-length s))\n              (reset! last-was-whitespace? (is-whitespace? (nth s (dec (count s)))))))\n\n          js/Number\n          (let [c (char x)]\n            (let [mod-c (if @last-was-whitespace? (string/upper-case c) c)]\n              (-write writer mod-c)\n              (reset! last-was-whitespace? (is-whitespace? c)))))))))"},
        "defdirectives" {:type "defmacro",
                         :key "defdirectives",
                         :lines [103 107],
                         :filename "pprint.clj",
                         :source "(defmacro ^{:private true}\n  defdirectives\n  [& directives]\n  `(def ^{:private true}\n        ~'directive-table (hash-map ~@(mapcat process-directive-table-element directives))))"},
        "consume" {:type "defn-",
                   :key "consume",
                   :lines [86 92],
                   :filename "pprint.cljs",
                   :source "(defn- consume [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result new-context] (apply func [context])]\n      (if (not result)\n        [acc new-context]\n        (recur new-context (conj acc result))))))"},
        "add-to-buffer" {:type "defn-",
                         :key "add-to-buffer",
                         :lines [434 437],
                         :filename "pprint.cljs",
                         :source "(defn- add-to-buffer [this token]\n  (setf :buffer (conj (getf :buffer) token))\n  (if (not (tokens-fit? this (getf :buffer)))\n    (write-line this)))"},
        "nl-t" {:type "deftype",
                :key "nl-t",
                :lines [254 254],
                :filename "pprint.cljs",
                :source "(deftype nl-t :type :logical-block :start-pos :end-pos)"},
        "single-defn" {:type "defn-",
                       :key "single-defn",
                       :lines [3015 3021],
                       :filename "pprint.cljs",
                       :source "(defn- single-defn [alis has-doc-str?]\n  (if (seq alis)\n    (do\n      (if has-doc-str?\n        ((formatter-out \" ~_\"))\n        ((formatter-out \" ~@_\")))\n      ((formatter-out \"~{~w~^ ~_~}\") alis))))"},
        "param-pattern" {:type "def",
                         :key "param-pattern",
                         :lines [2459 2460],
                         :filename "pprint.cljs",
                         :source "(def ^{:private true}\n     param-pattern #\"^([vV]|#|('.)|([+-]?\\d+)|(?=,))\")"},
        "start-block-t" {:type "deftype",
                         :key "start-block-t",
                         :lines [256 256],
                         :filename "pprint.cljs",
                         :source "(deftype start-block-t :logical-block :start-pos :end-pos)"},
        "set-field" {:type "defn-",
                     :key "set-field",
                     :lines [157 158],
                     :filename "pprint.cljs",
                     :source "(defn- set-field [this sym new-val]\n  (swap! @this assoc sym new-val))"},
        "write-token :buffer-blob" {:type "defmethod",
                                    :key "write-token :buffer-blob",
                                    :lines [290 291],
                                    :filename "pprint.cljs",
                                    :source "(defmethod write-token :buffer-blob [this token]\n  (-write (getf :base) (:data token)))"},
        "char-code" {:type "defn",
                     :key "char-code",
                     :lines [63 69],
                     :filename "pprint.cljs",
                     :source "(defn char-code\n  \"Convert char to int\"\n  [c]\n  (cond\n    (number? c) c\n    (and (string? c) (== (.-length c) 1)) (.charCodeAt c 0)\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))"},
        "format-ascii" {:type "defn-",
                        :key "format-ascii",
                        :lines [1043 1059],
                        :filename "pprint.cljs",
                        :source "(defn- format-ascii [print-func params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)\n        base-output (or (format-simple-number arg) (print-func arg))\n        base-width (.-length base-output)\n        min-width (+ base-width (:minpad params))\n        width (if (>= min-width (:mincol params))\n                min-width\n                (+ min-width\n                   (* (+ (quot (- (:mincol params) min-width 1)\n                               (:colinc params))\n                         1)\n                      (:colinc params))))\n        chars (apply str (repeat (- width base-width) (:padchar params)))]\n    (if (:at params)\n      (print (str chars base-output))\n      (print (str base-output chars)))\n    arg-navigator))"},
        "map-params" {:type "defn-",
                      :key "map-params",
                      :lines [2525 2553],
                      :filename "pprint.cljs",
                      :source "(defn- map-params\n  \"Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.\"\n  [def params flags offset]\n  (check-flags def flags)\n  (if (> (count params) (count (:params def)))\n    (format-error\n      (cl-format\n        nil\n        \"Too many parameters for directive \\\"~C\\\": ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed\"\n        (:directive def) (count params) (count (:params def)))\n      (second (first params))))\n  (doall\n    (map #(let [val (first %1)]\n           (if (not (or (nil? val) (contains? special-params val)\n                        (= (second (second %2)) (type val))))\n             (format-error (str \"Parameter \" (name (first %2))\n                                \" has bad type in directive \\\"\" (:directive def) \"\\\": \"\n                                (type val))\n                           (second %1))) )\n         params (:params def)))\n\n  (merge                                ; create the result map\n    (into (array-map) ; start with the default values, make sure the order is right\n          (reverse (for [[name [default]] (:params def)] [name [default offset]])))\n    (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils\n    flags))"},
        "emit-nl? :miser" {:type "defmethod",
                           :key "emit-nl? :miser",
                           :lines [342 344],
                           :filename "pprint.cljs",
                           :source "(defmethod emit-nl? :miser [newl this section _]\n  (let [lb (:logical-block newl)]\n    (miser-nl? this lb section)))"},
        "choice-conditional" {:type "defn-",
                              :key "choice-conditional",
                              :lines [1690 1699],
                              :filename "pprint.cljs",
                              :source "(defn- choice-conditional [params arg-navigator offsets]\n  (let [arg (:selector params)\n        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))\n        clauses (:clauses params)\n        clause (if (or (neg? arg) (>= arg (count clauses)))\n                 (first (:else params))\n                 (nth clauses arg))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))"},
        "*print-suppress-namespaces*" {:type "def",
                                       :key "*print-suppress-namespaces*",
                                       :lines [658 662],
                                       :filename "pprint.cljs",
                                       :source "(def ^:dynamic\n^{:doc \"Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions\"\n  :added \"1.2\"}\n*print-suppress-namespaces* nil)"},
        "tuple-map" {:type "defn-",
                     :key "tuple-map",
                     :lines [109 111],
                     :filename "pprint.cljs",
                     :source "(defn- tuple-map [m v1]\n  \"For all the values, v, in the map, replace them with [v v1]\"\n  (into {} (for [[k v] m] [k [v v1]])))"},
        "next-arg" {:type "defn-",
                    :key "next-arg",
                    :lines [955 959],
                    :filename "pprint.cljs",
                    :source "(defn- next-arg [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      (throw (js/Error \"Not enough arguments for format definition\")))))"},
        "pprint-ns" {:type "defn-",
                     :key "pprint-ns",
                     :lines [2977 3001],
                     :filename "pprint.cljs",
                     :source "(defn- pprint-ns\n  \"The pretty print dispatch chunk for the ns macro\"\n  [alis]\n  (if (next alis)\n    (let [[ns-sym ns-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map references] (if (map? (first stuff))\n                                  [(first stuff) (next stuff)]\n                                  [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") ns-sym ns-name)\n        (when (or doc-str attr-map (seq references))\n          ((formatter-out \"~@:_\")))\n        (when doc-str\n          (cl-format true \"\\\"~a\\\"~:[~;~:@_~]\" doc-str (or attr-map (seq references))))\n        (when attr-map\n          ((formatter-out \"~w~:[~;~:@_~]\") attr-map (seq references)))\n        (loop [references references]\n          (pprint-ns-reference (first references))\n          (when-let [references (next references)]\n            (pprint-newline :linear)\n            (recur references)))))\n    (write-out alis)))"},
        "execute-sub-format" {:type "defn-",
                              :key "execute-sub-format",
                              :lines [1380 1391],
                              :filename "pprint.cljs",
                              :source "(defn- execute-sub-format [format args base-args]\n  (second\n    (map-passing-context\n      (fn [element context]\n        (if (abort? context)\n          [nil context]    ; just keep passing it along\n          (let [[params args] (realize-parameter-list (:params element) context)\n                [params offsets] (unzip-map params)\n                params (assoc params :base-args base-args)]\n            [nil (apply (:func element) [params args offsets])])))\n      args\n      format)))"},
        "get-miser-width" {:type "defn-",
                           :key "get-miser-width",
                           :lines [604 605],
                           :filename "pprint.cljs",
                           :source "(defn- get-miser-width [this]\n  (getf :miser-width))"},
        "with-pprint-dispatch" {:type "defmacro",
                                :key "with-pprint-dispatch",
                                :lines [139 143],
                                :filename "pprint.clj",
                                :source "(defmacro with-pprint-dispatch\n  \"Execute body with the pretty print dispatch function bound to function.\"\n  [function & body]\n  `(cljs.core/binding [cljs.pprint/*print-pprint-dispatch* ~function]\n     ~@body))"},
        "setf" {:type "defmacro",
                :key "setf",
                :lines [26 29],
                :filename "pprint.clj",
                :source "(defmacro setf\n  \"Set the value of the field SYM to NEW-VAL\"\n  [sym new-val]\n  `(swap! @~'this assoc ~sym ~new-val))"},
        "map-passing-context" {:type "defn-",
                               :key "map-passing-context",
                               :lines [75 84],
                               :filename "pprint.cljs",
                               :source "(defn- map-passing-context [func initial-context lis]\n  (loop [context initial-context\n         lis lis\n         acc []]\n    (if (empty? lis)\n      [acc context]\n      (let [this (first lis)\n            remainder (next lis)\n            [result new-context] (apply func [this context])]\n        (recur new-context remainder (conj acc result))))))"},
        "*symbol-map*" {:type "def",
                        :key "*symbol-map*",
                        :lines [3126 3126],
                        :filename "pprint.cljs",
                        :source "(def ^:dynamic ^{:private true} *symbol-map* {})"},
        "javascript-base-formats" {:type "def",
                                   :key "javascript-base-formats",
                                   :lines [1103 1104],
                                   :filename "pprint.cljs",
                                   :source "(def ^{:private true}\n  javascript-base-formats {8 \"%o\", 10 \"%d\", 16 \"%x\"})"},
        "general-float" {:type "defn-",
                         :key "general-float",
                         :lines [1641 1660],
                         :filename "pprint.cljs",
                         :source "(defn- general-float [params navigator offsets]\n  (let [[arg _] (next-arg navigator)\n        arg (convert-ratio arg)\n        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))\n        w (:w params)\n        d (:d params)\n        e (:e params)\n        n (if (= arg 0.0) 0 (inc exp))\n        ee (if e (+ e 2) 4)\n        ww (if w (- w ee))\n        d (if d d (max (count mantissa) (min n 7)))\n        dd (- d n)]\n    (if (<= 0 dd d)\n      (let [navigator (fixed-float {:w ww, :d dd, :k 0,\n                                    :overflowchar (:overflowchar params),\n                                    :padchar (:padchar params), :at (:at params)}\n                                   navigator offsets)]\n        (print (apply str (repeat ee \\space)))\n        navigator)\n      (exponential-float params navigator offsets))))"},
        "process-nesting" {:type "defn-",
                           :key "process-nesting",
                           :lines [2670 2683],
                           :filename "pprint.cljs",
                           :source "(defn- process-nesting\n  \"Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure\"\n  [format]\n  (first\n    (consume\n      (fn [remainder]\n        (let [this (first remainder)\n              remainder (next remainder)\n              bracket (:bracket-info (:def this))]\n          (if (:right bracket)\n            (process-bracket this remainder)\n            [this remainder])))\n      format)))"},
        "level-exceeded" {:type "defn-",
                          :key "level-exceeded",
                          :lines [839 840],
                          :filename "pprint.cljs",
                          :source "(defn- level-exceeded []\n  (and *print-level* (>= *current-level* *print-level*)))"},
        "execute-format" {:type "defn-",
                          :key "execute-format",
                          :lines [2730 2764],
                          :filename "pprint.cljs",
                          :source "(defn- execute-format\n  \"Executes the format with the arguments.\"\n  {:skip-wiki true}\n  ([stream format args]\n   (let [sb (StringBuffer.)\n         real-stream (if (or (not stream) (true? stream))\n                       (StringBufferWriter. sb)\n                       stream)\n         wrapped-stream (if (and (needs-pretty format)\n                                 (not (pretty-writer? real-stream)))\n                          (get-pretty-writer real-stream)\n                          real-stream)]\n     (binding [*out* wrapped-stream]\n       (try\n         (execute-format format args)\n         (finally\n           (if-not (identical? real-stream wrapped-stream)\n             (-flush wrapped-stream))))\n       (cond\n         (not stream) (str sb)\n         (true? stream) (*print-fn* (str sb))\n         :else nil))))\n  ([format args]\n   (map-passing-context\n     (fn [element context]\n       (if (abort? context)\n         [nil context]\n         (let [[params args] (realize-parameter-list\n                               (:params element) context)\n               [params offsets] (unzip-map params)\n               params (assoc params :base-args args)]\n           [nil (apply (:func element) [params args offsets])])))\n     args\n     format)\n   nil))"},
        "boolean-conditional" {:type "defn-",
                               :key "boolean-conditional",
                               :lines [1702 1710],
                               :filename "pprint.cljs",
                               :source "(defn- boolean-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg\n                 (second clauses)\n                 (first clauses))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))"},
        "pprint-if" {:type "def",
                     :key "pprint-if",
                     :lines [3084 3084],
                     :filename "pprint.cljs",
                     :source "(def ^{:private true} pprint-if (formatter-out \"~:<~1I~w~^ ~@_~w~@{ ~_~w~}~:>\"))"},
        "get-pretty-writer" {:type "defn",
                             :key "get-pretty-writer",
                             :lines [2065 2100],
                             :filename "pprint.cljs",
                             :source "(defn get-pretty-writer\n  \"Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000\"\n  [writer]\n  (if (pretty-writer? writer)\n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))"},
        "absolute-reposition" {:type "defn-",
                               :key "absolute-reposition",
                               :lines [977 980],
                               :filename "pprint.cljs",
                               :source "(defn- absolute-reposition [navigator position]\n  (if (>= position (:pos navigator))\n    (relative-reposition navigator (- (:pos navigator) position))\n    (arg-navigator. (:seq navigator) (drop position (:seq navigator)) position)))"},
        "*print-shared*" {:type "def",
                          :key "*print-shared*",
                          :lines [653 656],
                          :filename "pprint.cljs",
                          :source "(def ^:dynamic\n^{:private true,\n  :doc \"Mark repeated structures rather than repeat them (N.B. This is not yet used)\"}\n*print-shared* nil)"},
        "write-option-table" {:type "def",
                              :key "write-option-table",
                              :lines [693 709],
                              :filename "pprint.cljs",
                              :source "(def ^{:private true} write-option-table\n  {;:array            *print-array*\n   :base             #'cljs.pprint/*print-base*,\n   ;;:case             *print-case*,\n   :circle           #'cljs.pprint/*print-circle*,\n   ;;:escape           *print-escape*,\n   ;;:gensym           *print-gensym*,\n   :length           #'cljs.core/*print-length*,\n   :level            #'cljs.core/*print-level*,\n   :lines            #'cljs.pprint/*print-lines*,\n   :miser-width      #'cljs.pprint/*print-miser-width*,\n   :dispatch         #'cljs.pprint/*print-pprint-dispatch*,\n   :pretty           #'cljs.pprint/*print-pretty*,\n   :radix            #'cljs.pprint/*print-radix*,\n   :readably         #'cljs.core/*print-readably*,\n   :right-margin     #'cljs.pprint/*print-right-margin*,\n   :suppress-namespaces #'cljs.pprint/*print-suppress-namespaces*})"},
        "pp-newline" {:type "def",
                      :key "pp-newline",
                      :lines [262 262],
                      :filename "pprint.cljs",
                      :source "(def ^:private pp-newline (fn [] \"\\n\"))"},
        "compile-format" {:type "defn-",
                          :key "compile-format",
                          :lines [2685 2703],
                          :filename "pprint.cljs",
                          :source "(defn- compile-format\n  \"Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you're using the same format string repeatedly\"\n  [format-str]\n  (binding [*format-str* format-str]\n    (process-nesting\n      (first\n        (consume\n          (fn [[s offset]]\n            (if (empty? s)\n              [nil s]\n              (let [tilde (.indexOf s \\~)]\n                (cond\n                  (neg? tilde) [(compile-raw-string s offset) [\"\" (+ offset (.-length s))]]\n                  (zero? tilde) (compile-directive (subs s 1) (inc offset))\n                  true\n                  [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))\n          [format-str 0])))))"},
        "realize-parameter-list" {:type "defn-",
                                  :key "realize-parameter-list",
                                  :lines [1015 1018],
                                  :filename "pprint.cljs",
                                  :source "(defn- realize-parameter-list [parameter-map navigator]\n  (let [[pairs new-navigator]\n        (map-passing-context realize-parameter navigator parameter-map)]\n    [(into {} pairs) new-navigator]))"},
        "write-white-space" {:type "defn-",
                             :key "write-white-space",
                             :lines [447 450],
                             :filename "pprint.cljs",
                             :source "(defn- write-white-space [this]\n  (when-let [tws (getf :trailing-white-space)]\n    (-write (getf :base) tws)\n    (setf :trailing-white-space nil)))"},
        "dollar-float" {:type "defn-",
                        :key "dollar-float",
                        :lines [1664 1680],
                        :filename "pprint.cljs",
                        :source "(defn- dollar-float [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)\n        [mantissa exp] (float-parts (Math/abs arg))\n        d (:d params)  ; digits after the decimal\n        n (:n params)  ; minimum digits before the decimal\n        w (:w params)  ; minimum field width\n        add-sign (or (:at params) (neg? arg))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr \\.)) \\0)) fixed-repr)\n        full-len (+ (count full-repr) (if add-sign 1 0))]\n    (print (str\n             (if (and (:colon params) add-sign) (if (neg? arg) \\- \\+))\n             (apply str (repeat (- w full-len) (:padchar params)))\n             (if (and (not (:colon params)) add-sign) (if (neg? arg) \\- \\+))\n             full-repr))\n    navigator))"},
        "get-field" {:type "defn-",
                     :key "get-field",
                     :lines [154 155],
                     :filename "pprint.cljs",
                     :source "(defn- get-field [this sym]\n  (sym @@this))"},
        "emit-nl? :linear" {:type "defmethod",
                            :key "emit-nl? :linear",
                            :lines [338 340],
                            :filename "pprint.cljs",
                            :source "(defmethod emit-nl? :linear [newl this section _]\n  (let [lb (:logical-block newl)]\n    (linear-nl? this lb section)))"},
        "format-integer" {:type "defn-",
                          :key "format-integer",
                          :lines [1116 1140],
                          :filename "pprint.cljs",
                          :source "(defn- format-integer [base params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)]\n    (if (integral? arg)\n      (let [neg (neg? arg)\n            pos-arg (if neg (- arg) arg)\n            raw-str (opt-base-str base pos-arg)\n            group-str (if (:colon params)\n                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))\n                              commas (repeat (count groups) (:commachar params))]\n                          (apply str (next (interleave commas groups))))\n                        raw-str)\n            signed-str (cond\n                         neg (str \"-\" group-str)\n                         (:at params) (str \"+\" group-str)\n                         true group-str)\n            padded-str (if (< (.-length signed-str) (:mincol params))\n                         (str (apply str (repeat (- (:mincol params) (.-length signed-str))\n                                                 (:padchar params)))\n                              signed-str)\n                         signed-str)]\n        (print padded-str))\n      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0\n                               :padchar (:padchar params) :at true}\n                    (init-navigator [arg]) nil))\n    arg-navigator))"},
        "relative-reposition" {:type "defn-",
                               :key "relative-reposition",
                               :lines [982 986],
                               :filename "pprint.cljs",
                               :source "(defn- relative-reposition [navigator position]\n  (let [newpos (+ (:pos navigator) position)]\n    (if (neg? position)\n      (absolute-reposition navigator newpos)\n      (arg-navigator. (:seq navigator) (drop position (:rest navigator)) newpos))))"},
        "render-clauses" {:type "defn-",
                          :key "render-clauses",
                          :lines [1846 1859],
                          :filename "pprint.cljs",
                          :source "(defn- render-clauses [clauses navigator base-navigator]\n  (loop [clauses clauses\n         acc []\n         navigator navigator]\n    (if (empty? clauses)\n      [acc navigator]\n      (let [clause (first clauses)\n            [iter-result result-str] (let [sb (StringBuffer.)]\n                                       (binding [*out* (StringBufferWriter. sb)]\n                                         [(execute-sub-format clause navigator base-navigator)\n                                          (str sb)]))]\n        (if (= :up-arrow (first iter-result))\n          [acc (second iter-result)]\n          (recur (next clauses) (conj acc result-str) iter-result))))))"},
        "*code-table*" {:type "def",
                        :key "*code-table*",
                        :lines [3179 3194],
                        :filename "pprint.cljs",
                        :source "(def ^:dynamic ^{:private true} *code-table*\n  (two-forms\n    (add-core-ns\n      {'def pprint-hold-first, 'defonce pprint-hold-first,\n       'defn pprint-defn, 'defn- pprint-defn, 'defmacro pprint-defn, 'fn pprint-defn,\n       'let pprint-let, 'loop pprint-let, 'binding pprint-let,\n       'with-local-vars pprint-let, 'with-open pprint-let, 'when-let pprint-let,\n       'if-let pprint-let, 'doseq pprint-let, 'dotimes pprint-let,\n       'when-first pprint-let,\n       'if pprint-if, 'if-not pprint-if, 'when pprint-if, 'when-not pprint-if,\n       'cond pprint-cond, 'condp pprint-condp,\n       'fn* pprint-anon-func,\n       '. pprint-hold-first, '.. pprint-hold-first, '-> pprint-hold-first,\n       'locking pprint-hold-first, 'struct pprint-hold-first,\n       'struct-map pprint-hold-first, 'ns pprint-ns\n       })))"},
        "remainders" {:type "defn-",
                      :key "remainders",
                      :lines [1076 1084],
                      :filename "pprint.cljs",
                      :source "(defn- remainders\n  \"Return the list of remainders (essentially the 'digits') of val in the given base\"\n  [base val]\n  (reverse\n    (first\n      (consume #(if (pos? %)\n                 [(rem % base) (quot % base)]\n                 [nil nil])\n               val))))"},
        "init-navigator" {:type "defn-",
                          :key "init-navigator",
                          :lines [947 952],
                          :filename "pprint.cljs",
                          :source "(defn- init-navigator\n  \"Create a new arg-navigator from the sequence with the position set to 0\"\n  {:skip-wiki true}\n  [s]\n  (let [s (seq s)]\n    (arg-navigator. s s 0)))"},
        "logical-block-or-justify" {:type "defn-",
                                    :key "logical-block-or-justify",
                                    :lines [1837 1840],
                                    :filename "pprint.cljs",
                                    :source "(defn- logical-block-or-justify [params navigator offsets]\n  (if (:colon (:right-params params))\n    (format-logical-block params navigator offsets)\n    (justify-clauses params navigator offsets)))"},
        "group-by*" {:type "defn-",
                     :key "group-by*",
                     :lines [1111 1114],
                     :filename "pprint.cljs",
                     :source "(defn- group-by* [unit lis]\n  (reverse\n    (first\n      (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))"},
        "insert-scaled-decimal" {:type "defn-",
                                 :key "insert-scaled-decimal",
                                 :lines [1507 1512],
                                 :filename "pprint.cljs",
                                 :source "(defn- insert-scaled-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m k]\n  (if (neg? k)\n    (str \".\" m)\n    (str (subs m 0 k) \".\" (subs m k))))"},
        "type-map" {:type "def",
                    :key "type-map",
                    :lines [2875 2877],
                    :filename "pprint.cljs",
                    :source "(def ^{:private true}\ntype-map {\"core$future_call\" \"Future\",\n          \"core$promise\" \"Promise\"})"},
        "write-tokens" {:type "defn-",
                        :key "write-tokens",
                        :lines [302 312],
                        :filename "pprint.cljs",
                        :source "(defn- write-tokens [this tokens force-trailing-whitespace]\n  (doseq [token tokens]\n    (if-not (= (:type-tag token) :nl-t)\n      (if-let [tws (getf :trailing-white-space)]\n        (-write (getf :base) tws)))\n    (write-token this token)\n    (setf :trailing-white-space (:trailing-white-space token))\n    (let [tws (getf :trailing-white-space)]\n      (when (and force-trailing-whitespace tws)\n        (-write (getf :base) tws)\n        (setf :trailing-white-space nil)))))"},
        "iterate-main-list" {:type "defn-",
                             :key "iterate-main-list",
                             :lines [1779 1799],
                             :filename "pprint.cljs",
                             :source "(defn- iterate-main-list [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator\n           last-pos (int -1)]\n      (if (and (not max-count) (= (:pos navigator) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error \"%@{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause navigator (:base-args params))]\n          (if (= :up-arrow (first iter-result))\n            (second iter-result)\n            (recur\n              (inc count) iter-result (:pos navigator))))))))"},
        "process-bracket" {:type "defn-",
                           :key "process-bracket",
                           :lines [2588 2595],
                           :filename "pprint.cljs",
                           :source "(defn- process-bracket [this remainder]\n  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))\n                                           (:offset this) remainder)]\n    [(compiled-directive.\n       (:func this) (:def this)\n       (merge (:params this) (tuple-map subex (:offset this)))\n       (:offset this))\n     remainder]))"},
        "pprint-let" {:type "defn-",
                      :key "pprint-let",
                      :lines [3070 3078],
                      :filename "pprint.cljs",
                      :source "(defn- pprint-let [alis]\n  (let [base-sym (first alis)]\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (if (and (next alis) (vector? (second alis)))\n        (do\n          ((formatter-out \"~w ~1I~@_\") base-sym)\n          (pprint-binding-form (second alis))\n          ((formatter-out \" ~_~{~w~^ ~_~}\") (next (rest alis))))\n        (pprint-simple-code-list alis)))))"},
        "pprint-condp" {:type "defn-",
                        :key "pprint-condp",
                        :lines [3106 3123],
                        :filename "pprint.cljs",
                        :source "(defn- pprint-condp [alis]\n  (if (> (count alis) 3)\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (pprint-indent :block 1)\n      (apply (formatter-out \"~w ~@_~w ~@_~w ~_\") alis)\n      (print-length-loop [alis (seq (drop 3 alis))]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (-write *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (-write *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))\n    (pprint-simple-code-list alis)))"},
        "opt-base-str" {:type "defn-",
                        :key "opt-base-str",
                        :lines [1106 1109],
                        :filename "pprint.cljs",
                        :source "(defn- opt-base-str\n  \"Return val as a string in the given base. No cljs format, so no improved performance.\"\n  [base val]\n  (base-str base val))"},
        "relative-tabulation" {:type "defn-",
                               :key "relative-tabulation",
                               :lines [2126 2133],
                               :filename "pprint.cljs",
                               :source "(defn- relative-tabulation [params navigator offsets]\n  (let [colrel (:colnum params)\n        colinc (:colinc params)\n        start-col (+ colrel (get-column (:base @@*out*)))\n        offset (if (pos? colinc) (rem start-col colinc) 0)\n        space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)"},
        "format-simple-ordinal" {:type "defn-",
                                 :key "format-simple-ordinal",
                                 :lines [1237 1257],
                                 :filename "pprint.cljs",
                                 :source "(defn- format-simple-ordinal\n  \"Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n      (if (and (pos? hundreds) (pos? tens)) \" \")\n      (if (pos? tens)\n        (if (< tens 20)\n          (nth english-ordinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (if (and (pos? ten-digit) (not (pos? unit-digit)))\n              (nth english-ordinal-tens ten-digit)\n              (str\n                (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n                (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n                (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))\n        (if (pos? hundreds) \"th\")))))"},
        "arg-navigator" {:type "defrecord",
                         :key "arg-navigator",
                         :lines [944 945],
                         :filename "pprint.cljs",
                         :source "(defrecord ^{:private true}\n  arg-navigator [seq rest pos])"},
        "special-chars" {:type "def",
                         :key "special-chars",
                         :lines [1343 1344],
                         :filename "pprint.cljs",
                         :source "(def ^{:private true}\n     special-chars {8 \"Backspace\", 9 \"Tab\", 10 \"Newline\", 13 \"Return\", 32 \"Space\"})"},
        "is-whitespace?" {:type "defn-",
                          :key "is-whitespace?",
                          :lines [1990 1992],
                          :filename "pprint.cljs",
                          :source "(defn- is-whitespace? [s]\n  (boolean\n    (#{\\space \\newline} s)))"},
        "write-out" {:type "defn",
                     :key "write-out",
                     :lines [725 747],
                     :filename "pprint.cljs",
                     :source "(defn write-out\n  \"Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \\\"write\\\" interface. \"\n  [object]\n  (let [length-reached (and *current-length*\n                            *print-length*\n                            (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (-write *out* \"...\") ;;TODO could this (incorrectly) print ... on the next line?\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))"},
        "emit-nl? :mandatory" {:type "defmethod",
                               :key "emit-nl? :mandatory",
                               :lines [352 353],
                               :filename "pprint.cljs",
                               :source "(defmethod emit-nl? :mandatory [_ _ _ _]\n  true)"},
        "write-token :end-block-t" {:type "defmethod",
                                    :key "write-token :end-block-t",
                                    :lines [277 280],
                                    :filename "pprint.cljs",
                                    :source "(defmethod write-token :end-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :end))\n  (when-let [suffix (:suffix (:logical-block token))]\n    (-write (getf :base) suffix)))"},
        "compile-raw-string" {:type "defn-",
                              :key "compile-raw-string",
                              :lines [2575 2576],
                              :filename "pprint.cljs",
                              :source "(defn- compile-raw-string [s offset]\n  (compiled-directive. (fn [_ a _] (print s) a) nil {:string s} offset))"},
        "unzip-map" {:type "defn-",
                     :key "unzip-map",
                     :lines [102 107],
                     :filename "pprint.cljs",
                     :source "(defn- unzip-map [m]\n  \"Take a  map that has pairs in the value slots and produce a pair of maps,\n   the first having all the first elements of the pairs and the second all\n   the second elements of the pairs\"\n  [(into {} (for [[k [v1 v2]] m] [k v1]))\n   (into {} (for [[k [v1 v2]] m] [k v2]))])"},
        "write-token :indent-t" {:type "defmethod",
                                 :key "write-token :indent-t",
                                 :lines [282 288],
                                 :filename "pprint.cljs",
                                 :source "(defmethod write-token :indent-t [this token]\n  (let [lb (:logical-block token)]\n    (reset! (:indent lb)\n            (+ (:offset token)\n               (condp = (:relative-to token)\n                 :block @(:start-col lb)\n                 :current (get-column (getf :base)))))))"},
        "realize-parameter" {:type "defn-",
                             :key "realize-parameter",
                             :lines [999 1013],
                             :filename "pprint.cljs",
                             :source "(defn- realize-parameter [[param [raw-val offset]] navigator]\n  (let [[real-param new-navigator]\n        (cond\n          (contains? #{:at :colon} param) ;pass flags through unchanged - this really isn't necessary\n          [raw-val navigator]\n\n          (= raw-val :parameter-from-args)\n          (next-arg navigator)\n\n          (= raw-val :remaining-arg-count)\n          [(count (:rest navigator)) navigator]\n\n          true\n          [raw-val navigator])]\n    [[param [real-param offset]] new-navigator]))"},
        "process-directive-table-element" {:type "defn-",
                                           :key "process-directive-table-element",
                                           :lines [95 101],
                                           :filename "pprint.clj",
                                           :source "(defn- process-directive-table-element [[char params flags bracket-info & generator-fn]]\n  [char,\n   {:directive char,\n    :params `(array-map ~@params),\n    :flags flags,\n    :bracket-info bracket-info,\n    :generator-fn (concat '(fn [params offset]) generator-fn)}])"},
        "end-block" {:type "defn-",
                     :key "end-block",
                     :lines [572 585],
                     :filename "pprint.cljs",
                     :source "(defn- end-block [this]\n  (let [lb (getf :logical-blocks)\n        suffix (:suffix lb)]\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (if suffix\n          (-write (getf :base) suffix))\n        (when-let [cb (getf :logical-block-callback)] (cb :end)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if suffix (count suffix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-end-block-t lb oldpos newpos))))\n    (setf :logical-blocks (:parent lb))))"},
        "add-core-ns" {:type "defn-",
                       :key "add-core-ns",
                       :lines [3170 3177],
                       :filename "pprint.cljs",
                       :source "(defn- add-core-ns [amap]\n  (let [core \"clojure.core\"]\n    (into {}\n      (map #(let [[s f] %]\n             (if (not (or (namespace s) (special-symbol? s)))\n               [(symbol core (name s)) f]\n               %))\n        amap))))"},
        "prefix-count" {:type "defn-",
                        :key "prefix-count",
                        :lines [134 142],
                        :filename "pprint.cljs",
                        :source "(defn- prefix-count [aseq val]\n  \"Return the number of times that val occurs at the start of sequence aseq,\nif val is a seq itself, count the number of times any element of val occurs at the\nbeginning of aseq\"\n  (let [test (if (coll? val) (set val) #{val})]\n    (loop [pos 0]\n      (if (or (= pos (count aseq)) (not (test (nth aseq pos))))\n        pos\n        (recur (inc pos))))))"},
        "format-logical-block" {:type "defn-",
                                :key "format-logical-block",
                                :lines [2141 2157],
                                :filename "pprint.cljs",
                                :source "(defn- format-logical-block [params navigator offsets]\n  (let [clauses (:clauses params)\n        clause-count (count clauses)\n        prefix (cond\n                 (> clause-count 1) (:string (:params (first (first clauses))))\n                 (:colon params) \"(\")\n        body (nth clauses (if (> clause-count 1) 1 0))\n        suffix (cond\n                 (> clause-count 2) (:string (:params (first (nth clauses 2))))\n                 (:colon params) \")\")\n        [arg navigator] (next-arg navigator)]\n    (pprint-logical-block :prefix prefix :suffix suffix\n      (execute-sub-format\n        body\n        (init-navigator arg)\n        (:base-args params)))\n    navigator))"},
        "pprint-reader-macro" {:type "defn-",
                               :key "pprint-reader-macro",
                               :lines [2807 2812],
                               :filename "pprint.cljs",
                               :source "(defn- pprint-reader-macro [alis]\n  (let [macro-char (reader-macros (first alis))]\n    (when (and macro-char (= 2 (count alis)))\n      (-write *out* macro-char)\n      (write-out (second alis))\n      true)))"},
        "IPrettyFlush" {:type "defprotocol",
                        :key "IPrettyFlush",
                        :lines [145 146],
                        :filename "pprint.cljs",
                        :source "(defprotocol IPrettyFlush\n  (-ppflush [pp]))"},
        "pretty-writer?" {:type "defn-",
                          :key "pretty-writer?",
                          :lines [716 718],
                          :filename "pprint.cljs",
                          :source "(defn- pretty-writer?\n  \"Return true iff x is a PrettyWriter\"\n  [x] (and (satisfies? IDeref x) (:pretty-writer @@x)))"},
        "base-str" {:type "defn-",
                    :key "base-str",
                    :lines [1088 1100],
                    :filename "pprint.cljs",
                    :source "(defn- base-str\n  \"Return val as a string in the given base\"\n  [base val]\n  (if (zero? val)\n    \"0\"\n    (let [xlated-val (cond\n                       ;(float? val) (bigdec val) ;;No bigdec\n                       ;(ratio? val) nil ;;No ratio\n                       :else val)]\n      (apply str\n             (map\n               #(if (< % 10) (char (+ (char-code \\0) %)) (char (+ (char-code \\a) (- % 10))))\n               (remainders base val))))))"},
        "*out*" {:type "def",
                 :key "*out*",
                 :lines [20 20],
                 :filename "pprint.cljs",
                 :source "(def ^:dynamic *out* nil)"},
        "*print-miser-width*" {:type "def",
                               :key "*print-miser-width*",
                               :lines [633 638],
                               :filename "pprint.cljs",
                               :source "(def ^:dynamic\n ^{:doc \"The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.\",\n   :added \"1.2\"}\n *print-miser-width* 40)"},
        "pprint-tab" {:type "defn",
                      :key "pprint-tab",
                      :lines [867 882],
                      :filename "pprint.cljs",
                      :source "(defn pprint-tab\n  \"Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n  {:added \"1.2\"}\n  [kind colnum colinc]\n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (js/Error. \"pprint-tab is not yet implemented\")))"},
        "check-arg-conditional" {:type "defn-",
                                 :key "check-arg-conditional",
                                 :lines [1714 1722],
                                 :filename "pprint.cljs",
                                 :source "(defn- check-arg-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg (first clauses))]\n    (if arg\n      (if clause\n        (execute-sub-format clause arg-navigator (:base-args params))\n        arg-navigator)\n      navigator)))"},
        "use-method" {:type "defn-",
                      :key "use-method",
                      :lines [2774 2777],
                      :filename "pprint.cljs",
                      :source "(defn- use-method\n  \"Installs a function as a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val func]\n  (-add-method multifn dispatch-val func))"},
        "print-length-loop" {:type "defmacro",
                             :key "print-length-loop",
                             :lines [84 93],
                             :filename "pprint.clj",
                             :source "(defmacro print-length-loop\n  \"A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.\"\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not cljs.core/*print-length*) (< ~count-var cljs.core/*print-length*))\n         (do ~@mod-body)\n         (~'-write cljs.pprint/*out* \"...\")))))"},
        "pprint-newline" {:type "defn",
                          :key "pprint-newline",
                          :lines [842 851],
                          :filename "pprint.cljs",
                          :source "(defn pprint-newline\n  \"Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.\"\n  [kind]\n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))"},
        "*print-base*" {:type "def",
                        :key "*print-base*",
                        :lines [673 676],
                        :filename "pprint.cljs",
                        :source "(def ^:dynamic\n^{:doc \"The base to use for printing integers and rationals.\"\n  :added \"1.2\"}\n*print-base* 10)"},
        "process-clause" {:type "defn-",
                          :key "process-clause",
                          :lines [2597 2619],
                          :filename "pprint.cljs",
                          :source "(defn- process-clause [bracket-info offset remainder]\n  (consume\n    (fn [remainder]\n      (if (empty? remainder)\n        (format-error \"No closing bracket found.\" offset)\n        (let [this (first remainder)\n              remainder (next remainder)]\n          (cond\n            (right-bracket this)\n            (process-bracket this remainder)\n\n            (= (:right bracket-info) (:directive (:def this)))\n            [ nil [:right-bracket (:params this) nil remainder]]\n\n            (else-separator? this)\n            [nil [:else nil (:params this) remainder]]\n\n            (separator? this)\n            [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;\n\n            true\n            [this remainder]))))\n    remainder))"},
        "multi-defn" {:type "defn-",
                      :key "multi-defn",
                      :lines [3024 3026],
                      :filename "pprint.cljs",
                      :source "(defn- multi-defn [alis has-doc-str?]\n  (if (seq alis)\n    ((formatter-out \" ~_~{~w~^ ~_~}\") alis)))"},
        "*format-str*" {:type "def",
                        :key "*format-str*",
                        :lines [931 931],
                        :filename "pprint.cljs",
                        :source "(def ^:dynamic ^{:private true} *format-str* nil)"},
        "reader-macros" {:type "def",
                         :key "reader-macros",
                         :lines [2799 2805],
                         :filename "pprint.cljs",
                         :source "(def ^{:private true} reader-macros\n  {'quote \"'\"\n   'var \"#'\"\n   'clojure.core/deref \"@\",\n   'clojure.core/unquote \"~\"\n   'cljs.core/deref \"@\",\n   'cljs.core/unquote \"~\"})"},
        "getf" {:type "defmacro",
                :key "getf",
                :lines [19 22],
                :filename "pprint.clj",
                :source "(defmacro getf\n  \"Get the value of the field a named by the argument (which should be a keyword).\"\n  [sym]\n  `(~sym @@~'this))"},
        "else-separator?" {:type "defn-",
                           :key "else-separator?",
                           :lines [2582 2584],
                           :filename "pprint.cljs",
                           :source "(defn- else-separator? [this]\n  (and (:separator (:bracket-info (:def this)))\n       (:colon (:params this))))"},
        "pprint-anon-func" {:type "defn-",
                            :key "pprint-anon-func",
                            :lines [3128 3140],
                            :filename "pprint.cljs",
                            :source "(defn- pprint-anon-func [alis]\n  (let [args (second alis)\n        nlis (first (rest (rest alis)))]\n    (if (vector? args)\n      (binding [*symbol-map* (if (= 1 (count args))\n                               {(first args) \"%\"}\n                               (into {}\n                                 (map\n                                   #(vector %1 (str \\% %2))\n                                   args\n                                   (range 1 (inc (count args))))))]\n        ((formatter-out \"~<#(~;~@{~w~^ ~_~}~;)~:>\") nlis))\n      (pprint-simple-code-list alis))))"},
        "set-indent" {:type "defn-",
                      :key "set-indent",
                      :lines [2159 2162],
                      :filename "pprint.cljs",
                      :source "(defn- set-indent [params navigator offsets]\n  (let [relative-to (if (:colon params) :current :block)]\n    (pprint-indent relative-to (:n params))\n    navigator))"},
        "write-token :nl-t" {:type "defmethod",
                             :key "write-token :nl-t",
                             :lines [293 300],
                             :filename "pprint.cljs",
                             :source "(defmethod write-token :nl-t [this token]\n  (if (or (= (:type token) :mandatory)\n          (and (not (= (:type token) :fill))\n               @(:done-nl (:logical-block token))))\n    (emit-nl this token)\n    (if-let [tws (getf :trailing-white-space)]\n      (-write (getf :base) tws)))\n  (setf :trailing-white-space nil))"},
        "extract-flags" {:type "defn-",
                         :key "extract-flags",
                         :lines [2497 2510],
                         :filename "pprint.cljs",
                         :source "(defn- extract-flags [s offset]\n  (consume\n    (fn [[s offset flags]]\n      (if (empty? s)\n        [nil [s offset flags]]\n        (let [flag (get flag-defs (first s))]\n          (if flag\n            (if (contains? flags flag)\n              (format-error\n                (str \"Flag \\\"\" (first s) \"\\\" appears more than once in a directive\")\n                offset)\n              [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])\n            [nil [s offset flags]]))))\n    [s offset {}]))"},
        "english-cardinal-tens" {:type "def",
                                 :key "english-cardinal-tens",
                                 :lines [1158 1160],
                                 :filename "pprint.cljs",
                                 :source "(def ^{:private true}\n     english-cardinal-tens\n     [\"\" \"\" \"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"])"},
        "float?" {:type "defn",
                  :key "float?",
                  :lines [55 61],
                  :filename "pprint.cljs",
                  :source "(defn ^boolean float?\n  \"Returns true if n is an float.\"\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (not (== (js/parseFloat n) (js/parseInt n 10)))))"},
        "integral?" {:type "defn-",
                     :key "integral?",
                     :lines [1066 1074],
                     :filename "pprint.cljs",
                     :source "(defn- integral?\n  \"returns true if a number is actually an integer (that is, has no fractional part)\"\n  [x]\n  (cond\n    (integer? x) true\n    ;;(decimal? x) ;;no decimal support\n    (float? x) (= x (Math/floor x))\n    ;;(ratio? x) ;;no ratio support\n    :else false))"},
        "write-token :start-block-t" {:type "defmethod",
                                      :key "write-token :start-block-t",
                                      :lines [268 275],
                                      :filename "pprint.cljs",
                                      :source "(defmethod write-token :start-block-t [this token]\n  (when-let [cb (getf :logical-block-callback)] (cb :start))\n  (let [lb (:logical-block token)]\n    (when-let [prefix (:prefix lb)]\n      (-write (getf :base) prefix))\n    (let [col (get-column (getf :base))]\n      (reset! (:start-col lb) col)\n      (reset! (:indent lb) col))))"},
        "is-letter?" {:type "defn-",
                      :key "is-letter?",
                      :lines [1960 1964],
                      :filename "pprint.cljs",
                      :source "(defn- is-letter? [s]\n  (boolean\n    (#{\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n       \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"}\n      s)))"},
        "*current-level*" {:type "def",
                           :key "*current-level*",
                           :lines [683 683],
                           :filename "pprint.cljs",
                           :source "(def ^:dynamic ^{:private true} *current-level* 0)"},
        "extract-params" {:type "defn-",
                          :key "extract-params",
                          :lines [2479 2480],
                          :filename "pprint.cljs",
                          :source "(defn- extract-params [s offset]\n  (consume extract-param [s offset false]))"},
        "*default-page-width*" {:type "def",
                                :key "*default-page-width*",
                                :lines [152 152],
                                :filename "pprint.cljs",
                                :source "(def ^:dynamic ^{:private true} *default-page-width* 72)"},
        "*print-radix*" {:type "def",
                         :key "*print-radix*",
                         :lines [666 671],
                         :filename "pprint.cljs",
                         :source "(def ^:dynamic\n^{:doc \"Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* \"\n  :added \"1.2\"}\n*print-radix* nil)"},
        "pprint-indent" {:type "defn",
                         :key "pprint-indent",
                         :lines [853 864],
                         :filename "pprint.cljs",
                         :source "(defn pprint-indent\n  \"Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  [relative-to n]\n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))"},
        "write-initial-lines" {:type "defn-",
                               :key "write-initial-lines",
                               :lines [454 477],
                               :filename "pprint.cljs",
                               :source "(defn- write-initial-lines\n  [^Writer this ^String s]\n  (let [lines (string/split s \"\\n\" -1)]\n    (if (= (count lines) 1)\n      s\n      (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))\n            ^String l (first lines)]\n        (if (= :buffering (getf :mode))\n          (let [oldpos (getf :pos)\n                newpos (+ oldpos (count l))]\n            (setf :pos newpos)\n            (add-to-buffer this (make-buffer-blob l nil oldpos newpos))\n            (write-buffered-output this))\n          (do\n            (write-white-space this)\n            (-write (getf :base) l)))\n        (-write (getf :base) \\newline)\n        (doseq [^String l (next (butlast lines))]\n          (-write (getf :base) l)\n          (-write (getf :base) (pp-newline))\n          (if prefix\n            (-write (getf :base) prefix)))\n        (setf :buffering :writing)\n        (last lines)))))"},
        "absolute-tabulation" {:type "defn-",
                               :key "absolute-tabulation",
                               :lines [2115 2124],
                               :filename "pprint.cljs",
                               :source "(defn- absolute-tabulation [params navigator offsets]\n  (let [colnum (:colnum params)\n        colinc (:colinc params)\n        current (get-column (:base @@*out*))\n        space-count (cond\n                      (< current colnum) (- colnum current)\n                      (= colinc 0) 0\n                      :else (- colinc (rem (- current colnum) colinc)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)"},
        "println" {:type "defn-",
                   :key "println",
                   :lines [29 31],
                   :filename "pprint.cljs",
                   :source "(defn- println [& more]\n  (apply print more)\n  (-write *out* \\newline))"},
        "type-dispatcher" {:type "defn-",
                           :key "type-dispatcher",
                           :lines [2899 2909],
                           :filename "pprint.cljs",
                           :source "(defn- type-dispatcher [obj]\n  (cond\n    (instance? PersistentQueue obj) :queue\n    (satisfies? IDeref obj) :deref\n    (symbol? obj) :symbol\n    (seq? obj) :list\n    (map? obj) :map\n    (vector? obj) :vector\n    (set? obj) :set\n    (nil? obj) nil\n    :default :default))"},
        "special-params" {:type "def",
                          :key "special-params",
                          :lines [2462 2463],
                          :filename "pprint.cljs",
                          :source "(def ^{:private true}\n     special-params #{:parameter-from-args :remaining-arg-count})"},
        "ltrim" {:type "defn-",
                 :key "ltrim",
                 :lines [124 132],
                 :filename "pprint.cljs",
                 :source "(defn- ltrim [s c]\n  \"Trim all instances of c from the beginning of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s 0) c))\n      (loop [n 0]\n        (if (or (= n len) (not (= (nth s n) c)))\n          (subs s n)\n          (recur (inc n))))\n      s)))"},
        "logical-block" {:type "defrecord",
                         :key "logical-block",
                         :lines [231 235],
                         :filename "pprint.cljs",
                         :source "(defrecord ^{:private true} logical-block\n  [parent section start-col indent\n   done-nl intra-block-nl\n   prefix per-line-prefix suffix\n   logical-block-callback])"},
        "set-max-column" {:type "defn-",
                          :key "set-max-column",
                          :lines [169 171],
                          :filename "pprint.cljs",
                          :source "(defn- set-max-column [this new-max]\n  (set-field this :max new-max)\n  nil)"},
        "english-cardinal-units" {:type "def",
                                  :key "english-cardinal-units",
                                  :lines [1146 1150],
                                  :filename "pprint.cljs",
                                  :source "(def ^{:private true}\n     english-cardinal-units\n     [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"\n      \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\n      \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"])"},
        "indent" {:type "defn-",
                  :key "indent",
                  :lines [592 602],
                  :filename "pprint.cljs",
                  :source "(defn- indent [this relative-to offset]\n  (let [lb (getf :logical-blocks)]\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (reset! (:indent lb)\n                (+ offset (condp = relative-to\n                            :block @(:start-col lb)\n                            :current (get-column (getf :base))))))\n      (let [pos (getf :pos)]\n        (add-to-buffer this (make-indent-t lb relative-to offset pos pos))))))"},
        "expand-fixed" {:type "defn-",
                        :key "expand-fixed",
                        :lines [1486 1494],
                        :filename "pprint.cljs",
                        :source "(defn- expand-fixed [m e d]\n  (let [[m1 e1] (if (neg? e)\n                  [(str (apply str (repeat (dec (- e)) \\0)) m) -1]\n                  [m e])\n        len (count m1)\n        target-len (if d (+ e1 d 1) (inc e1))]\n    (if (< len target-len)\n      (str m1 (apply str (repeat (- target-len len) \\0)))\n      m1)))"},
        "pprint-binding-form" {:type "defn-",
                               :key "pprint-binding-form",
                               :lines [3055 3068],
                               :filename "pprint.cljs",
                               :source "(defn- pprint-binding-form [binding-vec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [binding binding-vec]\n      (when (seq binding)\n        (pprint-logical-block binding\n          (write-out (first binding))\n          (when (next binding)\n            (-write *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second binding))))\n        (when (next (rest binding))\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next (rest binding))))))))"},
        "pprint-simple-default" {:type "defn-",
                                 :key "pprint-simple-default",
                                 :lines [2869 2871],
                                 :filename "pprint.cljs",
                                 :source "(defn- pprint-simple-default [obj]\n  ;;TODO: Update to handle arrays (?) and suppressing namespaces\n  (-write *out* (pr-str obj)))"},
        "modify-case" {:type "defn-",
                       :key "modify-case",
                       :lines [2055 2058],
                       :filename "pprint.cljs",
                       :source "(defn- modify-case [make-writer params navigator offsets]\n  (let [clause (first (:clauses params))]\n    (binding [*out* (make-writer *out*)]\n      (execute-sub-format clause navigator (:base-args params)))))"},
        "pprint-simple-list" {:type "defn-",
                              :key "pprint-simple-list",
                              :lines [2824 2832],
                              :filename "pprint.cljs",
                              :source "(defn- pprint-simple-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next alis)))))))"},
        "emit-nl?" {:type "defmulti",
                    :key "emit-nl?",
                    :lines [336 336],
                    :filename "pprint.cljs",
                    :source "(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))"},
        "fresh-line" {:type "defn",
                      :key "fresh-line",
                      :lines [2106 2113],
                      :filename "pprint.cljs",
                      :source "(defn fresh-line\n  \"Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n  []\n  (if (satisfies? IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))"},
        "format-simple-number" {:type "defn-",
                                :key "format-simple-number",
                                :lines [1033 1041],
                                :filename "pprint.cljs",
                                :source "(defn- format-simple-number [n]\n  (cond\n    (integer? n) (if (= *print-base* 10)\n                   (str n (if *print-radix* \".\"))\n                   (str\n                     (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                     (opt-base-str *print-base* n)))\n    ;;(ratio? n) ;;no ratio support\n    :else nil))"},
        "format-error" {:type "defn-",
                        :key "format-error",
                        :lines [933 936],
                        :filename "pprint.cljs",
                        :source "(defn- format-error [message offset]\n  (let [full-message (str message \\newline *format-str* \\newline\n                          (apply str (repeat offset \\space)) \"^\" \\newline)]\n    (throw (js/Error full-message))))"},
        "get-column" {:type "defn-",
                      :key "get-column",
                      :lines [160 161],
                      :filename "pprint.cljs",
                      :source "(defn- get-column [this]\n  (get-field this :cur))"},
        "start-block" {:type "defn-",
                       :key "start-block",
                       :lines [552 570],
                       :filename "pprint.cljs",
                       :source "(defn- start-block\n  [this prefix per-line-prefix suffix]\n  (let [lb (logical-block. (getf :logical-blocks) nil (atom 0) (atom 0)\n                           (atom false) (atom false)\n                           prefix per-line-prefix suffix nil)]\n    (setf :logical-blocks lb)\n    (if (= (getf :mode) :writing)\n      (do\n        (write-white-space this)\n        (when-let [cb (getf :logical-block-callback)] (cb :start))\n        (if prefix\n          (-write (getf :base) prefix))\n        (let [col (get-column (getf :base))]\n          (reset! (:start-col lb) col)\n          (reset! (:indent lb) col)))\n      (let [oldpos (getf :pos)\n            newpos (+ oldpos (if prefix (count prefix) 0))]\n        (setf :pos newpos)\n        (add-to-buffer this (make-start-block-t lb oldpos newpos))))))"},
        "prn" {:type "defn-",
               :key "prn",
               :lines [47 49],
               :filename "pprint.cljs",
               :source "(defn- prn [& more]\n  (apply pr more)\n  (-write *out* \\newline))"},
        "write-token" {:type "defmulti",
                       :key "write-token",
                       :lines [266 266],
                       :filename "pprint.cljs",
                       :source "(defmulti ^{:private true} write-token #(:type-tag %2))"},
        "write-token-string" {:type "defn-",
                              :key "write-token-string",
                              :lines [400 422],
                              :filename "pprint.cljs",
                              :source "(defn- write-token-string [this tokens]\n  (let [[a b] (split-at-newline tokens)]\n    (if a (write-tokens this a false))\n    (if b\n      (let [[section remainder] (get-section b)\n            newl (first b)]\n        (let [do-nl (emit-nl? newl this section (get-sub-section b))\n              result (if do-nl\n                       (do\n                         (emit-nl this newl)\n                         (next b))\n                       b)\n              long-section (not (tokens-fit? this result))\n              result (if long-section\n                       (let [rem2 (write-token-string this section)]\n                         (if (= rem2 section)\n                           (do ; If that didn't produce any output, it has no nls\n                             ; so we'll force it\n                             (write-tokens this section false)\n                             remainder)\n                           (into [] (concat rem2 remainder))))\n                       result)]\n          result)))))"},
        "column-writer" {:type "defn-",
                         :key "column-writer",
                         :lines [185 215],
                         :filename "pprint.cljs",
                         :source "(defn- column-writer\n  ([writer] (column-writer writer *default-page-width*))\n  ([writer max-columns]\n   (let [fields (atom {:max max-columns, :cur 0, :line 0 :base writer})]\n     (reify\n\n       IDeref\n       (-deref [_] fields)\n\n       IWriter\n       (-flush [_]\n         (-flush writer))\n       (-write\n         ;;-write isn't multi-arity, so need different way to do this\n         #_([this ^chars cbuf ^Number off ^Number len]\n          (let [writer (get-field this :base)]\n            (-write writer cbuf off len)))\n         [this x]\n         (condp = (type x)\n           js/String\n           (let [s x\n                 nl (.lastIndexOf s \\newline)]\n             (if (neg? nl)\n               (set-field this :cur (+ (get-field this :cur) (count s)))\n               (do\n                 (set-field this :cur (- (count s) nl 1))\n                 (set-field this :line (+ (get-field this :line)\n                                          (count (filter #(= % \\newline) s))))))\n             (-write (get-field this :base) s))\n           js/Number\n           (c-write-char this x)))))))"},
        "downcase-writer" {:type "defn-",
                           :key "downcase-writer",
                           :lines [1917 1936],
                           :filename "pprint.cljs",
                           :source "(defn- downcase-writer\n  \"Returns a proxy that wraps writer, converting all characters to lower case\"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp = (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/lower-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/lower-case (char c))))))))"},
        "update-nl-state" {:type "defn-",
                           :key "update-nl-state",
                           :lines [374 381],
                           :filename "pprint.cljs",
                           :source "(defn- update-nl-state [lb]\n  (reset! (:intra-block-nl lb) true)\n  (reset! (:done-nl lb) true)\n  (loop [lb (:parent lb)]\n    (if lb\n      (do (reset! (:done-nl lb) true)\n          (reset! (:intra-block-nl lb) true)\n          (recur (:parent lb))))))"},
        "format-cardinal-english" {:type "defn-",
                                   :key "format-cardinal-english",
                                   :lines [1220 1235],
                                   :filename "pprint.cljs",
                                   :source "(defn- format-cardinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zero\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal parts)\n                full-str (add-english-scales parts-strs 0)]\n            (print (str (if (neg? arg) \"minus \") full-str)))\n          (format-integer ;; for numbers > 10^63, we fall back on ~D\n            10\n            {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n            (init-navigator [arg])\n            {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))\n    navigator))"},
        "format-simple-cardinal" {:type "defn-",
                                  :key "format-simple-cardinal",
                                  :lines [1179 1195],
                                  :filename "pprint.cljs",
                                  :source "(defn- format-simple-cardinal\n  \"Convert a number less than 1000 to a cardinal english string\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n      (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n      (if (and (pos? hundreds) (pos? tens)) \" \")\n      (if (pos? tens)\n        (if (< tens 20)\n          (nth english-cardinal-units tens)\n          (let [ten-digit (quot tens 10)\n                unit-digit (rem tens 10)]\n            (str\n              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n              (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n              (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))"},
        "cached-compile" {:type "def",
                          :key "cached-compile",
                          :lines [2768 2768],
                          :filename "pprint.cljs",
                          :source "(def ^{:private true} cached-compile (memoize compile-format))"},
        "*print-pretty*" {:type "def",
                          :key "*print-pretty*",
                          :lines [616 618],
                          :filename "pprint.cljs",
                          :source "(def ^:dynamic\n ^{:doc \"Bind to true if you want write to use pretty printing\"}\n *print-pretty* true)"},
        "get-fixed" {:type "defn-",
                     :key "get-fixed",
                     :lines [1504 1505],
                     :filename "pprint.cljs",
                     :source "(defn- get-fixed [m e d]\n  (insert-decimal (expand-fixed m e d) e))"},
        "pprint-pqueue" {:type "def",
                         :key "pprint-pqueue",
                         :lines [2897 2897],
                         :filename "pprint.cljs",
                         :source "(def ^{:private true} pprint-pqueue (formatter-out \"~<<-(~;~@{~w~^ ~_~}~;)-<~:>\"))"},
        "readable-character" {:type "defn-",
                              :key "readable-character",
                              :lines [1360 1366],
                              :filename "pprint.cljs",
                              :source "(defn- readable-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)]\n    (condp = (:char-format params)\n      \\o (cl-format true \"\\\\o~3, '0o\" (char-code c))\n      \\u (cl-format true \"\\\\u~4, '0x\" (char-code c))\n      nil (print-char c))\n    navigator))"},
        "capitalize-string" {:type "defn-",
                             :key "capitalize-string",
                             :lines [1966 1987],
                             :filename "pprint.cljs",
                             :source "(defn- capitalize-string\n  \"Capitalizes the words in a string. If first? is false, don't capitalize the\n                                      first character of the string even if it's a letter.\"\n  [s first?]\n  (let [f (first s)\n        s (if (and first? f (is-letter? f))\n            (str (string/upper-case f) (subs s 1))\n            s)]\n    (apply str\n           (first\n             (consume\n               (fn [s]\n                 (if (empty? s)\n                   [nil nil]\n                   (let [m (.exec (js/RegExp \"\\\\W\\\\w\" \"g\") s)\n                         offset (and m (inc (.-index m)))]\n                     (if offset\n                       [(str (subs s 0 offset)\n                             (string/upper-case (nth s offset)))\n                        (subs s (inc offset))]\n                       [s nil]))))\n               s)))))"},
        "indent-t" {:type "deftype",
                    :key "indent-t",
                    :lines [260 260],
                    :filename "pprint.cljs",
                    :source "(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)"},
        "abort?" {:type "defn-",
                  :key "abort?",
                  :lines [1375 1377],
                  :filename "pprint.cljs",
                  :source "(defn- abort? [context]\n  (let [token (first context)]\n    (or (= :up-arrow token) (= :colon-up-arrow token))))"},
        "exponential-float" {:type "defn-",
                             :key "exponential-float",
                             :lines [1567 1634],
                             :filename "pprint.cljs",
                             :source "(defn- exponential-float [params navigator offset]\n  (let [[arg navigator] (next-arg navigator)\n        arg (convert-ratio arg)]\n    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]\n      (let [w (:w params)\n            d (:d params)\n            e (:e params)\n            k (:k params)\n            expchar (or (:exponentchar params) \\E)\n            add-sign (or (:at params) (neg? arg))\n            prepend-zero (<= k 0)\n            scaled-exp (- exp (dec k))\n            scaled-exp-str (str (Math/abs scaled-exp))\n            scaled-exp-str (str expchar (if (neg? scaled-exp) \\- \\+)\n                                (if e (apply str\n                                             (repeat\n                                               (- e\n                                                  (count scaled-exp-str))\n                                               \\0)))\n                                scaled-exp-str)\n            exp-width (count scaled-exp-str)\n            base-mantissa-width (count mantissa)\n            scaled-mantissa (str (apply str (repeat (- k) \\0))\n                                 mantissa\n                                 (if d\n                                   (apply str\n                                          (repeat\n                                            (- d (dec base-mantissa-width)\n                                               (if (neg? k) (- k) 0)) \\0))))\n            w-mantissa (if w (- w exp-width))\n            [rounded-mantissa _ incr-exp] (round-str\n                                            scaled-mantissa 0\n                                            (cond\n                                              (= k 0) (dec d)\n                                              (pos? k) d\n                                              (neg? k) (dec d))\n                                            (if w-mantissa\n                                              (- w-mantissa (if add-sign 1 0))))\n            full-mantissa (insert-scaled-decimal rounded-mantissa k)\n            append-zero (and (= k (count rounded-mantissa)) (nil? d))]\n        (if (not incr-exp)\n          (if w\n            (let [len (+ (count full-mantissa) exp-width)\n                  signed-len (if add-sign (inc len) len)\n                  prepend-zero (and prepend-zero (not (= signed-len w)))\n                  full-len (if prepend-zero (inc signed-len) signed-len)\n                  append-zero (and append-zero (< full-len w))]\n              (if (and (or (> full-len w) (and e (> (- exp-width 2) e)))\n                       (:overflowchar params))\n                (print (apply str (repeat w (:overflowchar params))))\n                (print (str\n                         (apply str\n                                (repeat\n                                  (- w full-len (if append-zero 1 0))\n                                  (:padchar params)))\n                         (if add-sign (if (neg? arg) \\- \\+))\n                         (if prepend-zero \"0\")\n                         full-mantissa\n                         (if append-zero \"0\")\n                         scaled-exp-str))))\n            (print (str\n                     (if add-sign (if (neg? arg) \\- \\+))\n                     (if prepend-zero \"0\")\n                     full-mantissa\n                     (if append-zero \"0\")\n                     scaled-exp-str)))\n          (recur [rounded-mantissa (inc exp)]))))\n    navigator))"},
        "pprint-list" {:type "defn-",
                       :key "pprint-list",
                       :lines [2834 2836],
                       :filename "pprint.cljs",
                       :source "(defn- pprint-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (pprint-simple-list alis)))"},
        "pprint-code-symbol" {:type "defn-",
                              :key "pprint-code-symbol",
                              :lines [3202 3207],
                              :filename "pprint.cljs",
                              :source "(defn- pprint-code-symbol [sym]\n  (if-let [arg-num (sym *symbol-map*)]\n    (print arg-num)\n    (if *print-suppress-namespaces*\n      (print (name sym))\n      (pr sym))))"},
        "justify-clauses" {:type "defn-",
                           :key "justify-clauses",
                           :lines [1862 1907],
                           :filename "pprint.cljs",
                           :source "(defn- justify-clauses [params navigator offsets]\n  (let [[[eol-str] new-navigator] (when-let [else (:else params)]\n                                    (render-clauses else navigator (:base-args params)))\n        navigator (or new-navigator navigator)\n        [else-params new-navigator] (when-let [p (:else-params params)]\n                                      (realize-parameter-list p navigator))\n        navigator (or new-navigator navigator)\n        min-remaining (or (first (:min-remaining else-params)) 0)\n        max-columns (or (first (:max-columns else-params))\n                        (get-max-column *out*))\n        clauses (:clauses params)\n        [strs navigator] (render-clauses clauses navigator (:base-args params))\n        slots (max 1\n                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))\n        chars (reduce + (map count strs))\n        mincol (:mincol params)\n        minpad (:minpad params)\n        colinc (:colinc params)\n        minout (+ chars (* slots minpad))\n        result-columns (if (<= minout mincol)\n                         mincol\n                         (+ mincol (* colinc\n                                      (+ 1 (quot (- minout mincol 1) colinc)))))\n        total-pad (- result-columns chars)\n        pad (max minpad (quot total-pad slots))\n        extra-pad (- total-pad (* pad slots))\n        pad-str (apply str (repeat pad (:padchar params)))]\n    (if (and eol-str (> (+ (get-column (:base @@*out*)) min-remaining result-columns)\n                        max-columns))\n      (print eol-str))\n    (loop [slots slots\n           extra-pad extra-pad\n           strs strs\n           pad-only (or (:colon params)\n                        (and (= (count strs) 1) (not (:at params))))]\n      (if (seq strs)\n        (do\n          (print (str (if (not pad-only) (first strs))\n                      (if (or pad-only (next strs) (:at params)) pad-str)\n                      (if (pos? extra-pad) (:padchar params))))\n          (recur\n            (dec slots)\n            (dec extra-pad)\n            (if pad-only strs (next strs))\n            false))))\n    navigator))"},
        "fixed-float" {:type "defn-",
                       :key "fixed-float",
                       :lines [1520 1562],
                       :filename "pprint.cljs",
                       :source "(defn- fixed-float [params navigator offsets]\n  (let [w (:w params)\n        d (:d params)\n        [arg navigator] (next-arg navigator)\n        [sign abs] (if (neg? arg) [\"-\" (- arg)] [\"+\" arg])\n        abs (convert-ratio abs)\n        [mantissa exp] (float-parts abs)\n        scaled-exp (+ exp (:k params))\n        add-sign (or (:at params) (neg? arg))\n        append-zero (and (not d) (<= (dec (count mantissa)) scaled-exp))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp\n                                                          d (if w (- w (if add-sign 1 0))))\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        fixed-repr (if (and w d\n                            (>= d 1)\n                            (= (.charAt fixed-repr 0) \\0)\n                            (= (.charAt fixed-repr 1) \\.)\n                            (> (count fixed-repr) (- w (if add-sign 1 0))))\n                     (subs fixed-repr 1)    ;chop off leading 0\n                     fixed-repr)\n        prepend-zero (= (first fixed-repr) \\.)]\n    (if w\n      (let [len (count fixed-repr)\n            signed-len (if add-sign (inc len) len)\n            prepend-zero (and prepend-zero (not (>= signed-len w)))\n            append-zero (and append-zero (not (>= signed-len w)))\n            full-len (if (or prepend-zero append-zero)\n                       (inc signed-len)\n                       signed-len)]\n        (if (and (> full-len w) (:overflowchar params))\n          (print (apply str (repeat w (:overflowchar params))))\n          (print (str\n                   (apply str (repeat (- w full-len) (:padchar params)))\n                   (if add-sign sign)\n                   (if prepend-zero \"0\")\n                   fixed-repr\n                   (if append-zero \"0\")))))\n      (print (str\n               (if add-sign sign)\n               (if prepend-zero \"0\")\n               fixed-repr\n               (if append-zero \"0\"))))\n    navigator))"},
        "get-section" {:type "defn-",
                       :key "get-section",
                       :lines [359 364],
                       :filename "pprint.cljs",
                       :source "(defn- get-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))\n                                 (next buffer)))]\n    [section (seq (drop (inc (count section)) buffer))]))"},
        "get-max-column" {:type "defn-",
                          :key "get-max-column",
                          :lines [166 167],
                          :filename "pprint.cljs",
                          :source "(defn- get-max-column [this]\n  (get-field this :max))"},
        "emit-nl? :fill" {:type "defmethod",
                          :key "emit-nl? :fill",
                          :lines [346 350],
                          :filename "pprint.cljs",
                          :source "(defmethod emit-nl? :fill [newl this section subsection]\n  (let [lb (:logical-block newl)]\n    (or @(:intra-block-nl lb)\n        (not (tokens-fit? this subsection))\n        (miser-nl? this lb section))))"},
        "pprint-hold-first" {:type "def",
                             :key "pprint-hold-first",
                             :lines [3008 3008],
                             :filename "pprint.cljs",
                             :source "(def ^{:private true} pprint-hold-first (formatter-out \"~:<~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:>\"))"},
        "inc-s" {:type "defn-",
                 :key "inc-s",
                 :lines [1424 1438],
                 :filename "pprint.cljs",
                 :source "(defn- inc-s\n  \"Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer.\"\n  [s]\n  (let [len-1 (dec (count s))]\n    (loop [i (int len-1)]\n      (cond\n        (neg? i) (apply str \"1\" (repeat (inc len-1) \"0\"))\n        (= \\9 (.charAt s i)) (recur (dec i))\n        :else (apply str (subs s 0 i)\n                     (char (inc (char-code (.charAt s i))))\n                     (repeat (- len-1 i) \"0\"))))))"},
        "linear-nl?" {:type "defn-",
                      :key "linear-nl?",
                      :lines [325 327],
                      :filename "pprint.cljs",
                      :source "(defn- linear-nl? [this lb section]\n  (or @(:done-nl lb)\n      (not (tokens-fit? this section))))"},
        "brackets" {:type "defn-",
                    :key "brackets",
                    :lines [2936 2941],
                    :filename "pprint.cljs",
                    :source "(defn- brackets\n  \"Figure out which kind of brackets to use\"\n  [form]\n  (if (vector? form)\n    [\"[\" \"]\"]\n    [\"(\" \")\"]))"},
        "iterate-list-of-sublists" {:type "defn-",
                                    :key "iterate-list-of-sublists",
                                    :lines [1756 1775],
                                    :filename "pprint.cljs",
                                    :source "(defn- iterate-list-of-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)]\n    (loop [count 0\n           arg-list arg-list]\n      (if (or (and (empty? arg-list)\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format\n                            clause\n                            (init-navigator (first arg-list))\n                            (init-navigator (next arg-list)))]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) (next arg-list))))))))"},
        "float-parts-base" {:type "defn-",
                            :key "float-parts-base",
                            :lines [1398 1410],
                            :filename "pprint.cljs",
                            :source "(defn- float-parts-base\n  \"Produce string parts for the mantissa (normalize 1-9) and exponent\"\n  [f]\n  (let [s (string/lower-case (str f))\n        exploc (.indexOf s \\e)\n        dotloc (.indexOf s \\.)]\n    (if (neg? exploc)\n      (if (neg? dotloc)\n        [s (str (dec (count s)))]\n        [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))])\n      (if (neg? dotloc)\n        [(subs s 0 exploc) (subs s (inc exploc))]\n        [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))]))))"},
        "pprint-logical-block" {:type "defmacro",
                                :key "pprint-logical-block",
                                :lines [49 71],
                                :filename "pprint.clj",
                                :source "(defmacro pprint-logical-block\n  \"Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.\"\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (cljs.pprint/level-exceeded)\n           (~'-write cljs.pprint/*out* \"#\")\n           (do\n             (cljs.core/binding [cljs.pprint/*current-level* (inc cljs.pprint/*current-level*)\n                       cljs.pprint/*current-length* 0]\n               (cljs.pprint/start-block cljs.pprint/*out*\n                                        ~(:prefix options)\n                                        ~(:per-line-prefix options)\n                                        ~(:suffix options))\n               ~@body\n               (cljs.pprint/end-block cljs.pprint/*out*))))\n         nil)))"},
        "print-table" {:type "defn",
                       :key "print-table",
                       :lines [3308 3332],
                       :filename "pprint.cljs",
                       :source "(defn print-table\n  \"Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n  {:added \"1.3\"}\n  ([ks rows]\n   (binding [*print-newline*]\n     (when (seq rows)\n       (let [widths (map\n                      (fn [k]\n                        (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                      ks)\n             spacers (map #(apply str (repeat % \"-\")) widths)\n             fmt-row (fn [leader divider trailer row]\n                       (str leader\n                            (apply str (interpose divider\n                                                  (for [[col width] (map vector (map #(get row %) ks) widths)]\n                                                    (add-padding width (str col)))))\n                            trailer))]\n         (cljs.core/println)\n         (cljs.core/println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n         (cljs.core/println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n         (doseq [row rows]\n           (cljs.core/println (fmt-row \"| \" \" | \" \" |\" row)))))))\n  ([rows] (print-table (keys (first rows)) rows)))"},
        "c-write-char" {:type "defn-",
                        :key "c-write-char",
                        :lines [177 183],
                        :filename "pprint.cljs",
                        :source "(defn- c-write-char [this c]\n  (if (= c \\newline)\n    (do\n      (set-field this :cur 0)\n      (set-field this :line (inc (get-field this :line))))\n    (set-field this :cur (inc (get-field this :cur))))\n  (-write (get-field this :base) c))"},
        "old-roman-table" {:type "def",
                           :key "old-roman-table",
                           :lines [1295 1300],
                           :filename "pprint.cljs",
                           :source "(def ^{:private true}\n     old-roman-table\n     [[ \"I\" \"II\" \"III\" \"IIII\" \"V\" \"VI\" \"VII\" \"VIII\" \"VIIII\"]\n      [ \"X\" \"XX\" \"XXX\" \"XXXX\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"LXXXX\"]\n      [ \"C\" \"CC\" \"CCC\" \"CCCC\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"DCCCC\"]\n      [ \"M\" \"MM\" \"MMM\"]])"},
        "split-at-newline" {:type "defn-",
                            :key "split-at-newline",
                            :lines [394 396],
                            :filename "pprint.cljs",
                            :source "(defn- split-at-newline [tokens]\n  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]\n    [pre (seq (drop (count pre) tokens))]))"},
        "flag-defs" {:type "def",
                     :key "flag-defs",
                     :lines [2494 2495],
                     :filename "pprint.cljs",
                     :source "(def ^{:private true}\n     flag-defs {\\: :colon, \\@ :at})"},
        "add-padding" {:type "defn-",
                       :key "add-padding",
                       :lines [3304 3306],
                       :filename "pprint.cljs",
                       :source "(defn- add-padding [width s]\n  (let [padding (max 0 (- width (count s)))]\n    (apply str (clojure.string/join (repeat padding \\space)) s)))"},
        "special-radix-markers" {:type "def",
                                 :key "special-radix-markers",
                                 :lines [1030 1031],
                                 :filename "pprint.cljs",
                                 :source "(def ^{:private true}\n  special-radix-markers {2 \"#b\" 8 \"#o\" 16 \"#x\"})"},
        "english-scale-numbers" {:type "def",
                                 :key "english-scale-numbers",
                                 :lines [1171 1177],
                                 :filename "pprint.cljs",
                                 :source "(def ^{:private true}\n     english-scale-numbers\n     [\"\" \"thousand\" \"million\" \"billion\" \"trillion\" \"quadrillion\" \"quintillion\"\n      \"sextillion\" \"septillion\" \"octillion\" \"nonillion\" \"decillion\"\n      \"undecillion\" \"duodecillion\" \"tredecillion\" \"quattuordecillion\"\n      \"quindecillion\" \"sexdecillion\" \"septendecillion\"\n      \"octodecillion\" \"novemdecillion\" \"vigintillion\"])"},
        "formatter" {:type "defmacro",
                     :key "formatter",
                     :lines [109 123],
                     :filename "pprint.clj",
                     :source "(defmacro formatter\n  \"Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.\"\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# cljs.pprint/cached-compile\n         my-e-f# cljs.pprint/execute-format\n         my-i-n# cljs.pprint/init-navigator\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))"},
        "needs-pretty" {:type "defn-",
                        :key "needs-pretty",
                        :lines [2705 2716],
                        :filename "pprint.cljs",
                        :source "(defn- needs-pretty\n  \"determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing\"\n  [format]\n  (loop [format format]\n    (if (empty? format)\n      false\n      (if (or (:pretty (:flags (:def (first format))))\n              (some needs-pretty (first (:clauses (:params (first format)))))\n              (some needs-pretty (first (:else (:params (first format))))))\n        true\n        (recur (next format))))))"},
        "print" {:type "defn-",
                 :key "print",
                 :lines [26 27],
                 :filename "pprint.cljs",
                 :source "(defn- print [& more]\n  (-write *out* (apply print-str more)))"},
        "get-sub-section" {:type "defn-",
                           :key "get-sub-section",
                           :lines [366 372],
                           :filename "pprint.cljs",
                           :source "(defn- get-sub-section [buffer]\n  (let [nl (first buffer)\n        lb (:logical-block nl)\n        section (seq (take-while #(let [nl-lb (:logical-block %)]\n                                   (not (and (nl-t? %) (or (= nl-lb lb) (ancestor? nl-lb lb)))))\n                                 (next buffer)))]\n    section))"},
        "pprint-map" {:type "defn-",
                      :key "pprint-map",
                      :lines [2852 2867],
                      :filename "pprint.cljs",
                      :source "(defn- pprint-map [amap]\n  (pprint-logical-block :prefix \"{\" :suffix \"}\"\n    (print-length-loop [aseq (seq amap)]\n      (when aseq\n        ;;compiler gets confused with nested macro if it isn't namespaced\n        ;;it tries to use clojure.pprint/pprint-logical-block for some reason\n        (m/pprint-logical-block\n          (write-out (ffirst aseq))\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (set! *current-length* 0)   ;always print both parts of the [k v] pair\n          (write-out (fnext (first aseq))))\n        (when (next aseq)\n          (-write *out* \", \")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))"},
        "pll-mod-body" {:type "defn-",
                        :key "pll-mod-body",
                        :lines [73 82],
                        :filename "pprint.clj",
                        :source "(defn- pll-mod-body [var-sym body]\n  (letfn [(inner [form]\n                 (if (seq? form)\n                   (let [form (macroexpand form)]\n                     (condp = (first form)\n                       'loop* form\n                       'recur (concat `(recur (inc ~var-sym)) (rest form))\n                       (walk/walk inner identity form)))\n                   form))]\n    (walk/walk inner identity body)))"},
        "english-ordinal-tens" {:type "def",
                                :key "english-ordinal-tens",
                                :lines [1162 1165],
                                :filename "pprint.cljs",
                                :source "(def ^{:private true}\n     english-ordinal-tens\n     [\"\" \"\" \"twentieth\" \"thirtieth\" \"fortieth\" \"fiftieth\"\n      \"sixtieth\" \"seventieth\" \"eightieth\" \"ninetieth\"])"},
        "convert-ratio" {:type "defn-",
                         :key "convert-ratio",
                         :lines [1515 1516],
                         :filename "pprint.cljs",
                         :source "(defn- convert-ratio [x]\n  x)"},
        "plain-character" {:type "defn-",
                           :key "plain-character",
                           :lines [1368 1371],
                           :filename "pprint.cljs",
                           :source "(defn- plain-character [params navigator offsets]\n  (let [[char navigator] (next-arg navigator)]\n    (print char)\n    navigator))"},
        "map-ref-type" {:type "defn-",
                        :key "map-ref-type",
                        :lines [2879 2884],
                        :filename "pprint.cljs",
                        :source "(defn- map-ref-type\n  \"Map ugly type names to something simpler\"\n  [name]\n  (or (when-let [match (re-find #\"^[^$]+\\$[^$]+\" name)]\n        (type-map match))\n    name))"},
        "ancestor?" {:type "defn-",
                     :key "ancestor?",
                     :lines [237 242],
                     :filename "pprint.cljs",
                     :source "(defn- ancestor? [parent child]\n  (loop [child (:parent child)]\n    (cond\n      (nil? child) false\n      (identical? parent child) true\n      :else (recur (:parent child)))))"},
        "new-roman-table" {:type "def",
                           :key "new-roman-table",
                           :lines [1302 1307],
                           :filename "pprint.cljs",
                           :source "(def ^{:private true}\n     new-roman-table\n     [[ \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n      [ \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n      [ \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n      [ \"M\" \"MM\" \"MMM\"]])"},
        "iterate-main-sublists" {:type "defn-",
                                 :key "iterate-main-sublists",
                                 :lines [1803 1819],
                                 :filename "pprint.cljs",
                                 :source "(defn- iterate-main-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator]\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [[sublist navigator] (next-arg-or-nil navigator)\n              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) navigator)))))))"},
        "pretty-character" {:type "defn-",
                            :key "pretty-character",
                            :lines [1346 1358],
                            :filename "pprint.cljs",
                            :source "(defn- pretty-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)\n        as-int (char-code c)\n        base-char (bit-and as-int 127)\n        meta (bit-and as-int 128)\n        special (get special-chars base-char)]\n    (if (> meta 0) (print \"Meta-\"))\n    (print (cond\n             special special\n             (< base-char 32) (str \"Control-\" (char (+ base-char 64)))\n             (= base-char 127) \"Control-?\"\n             :else (char base-char)))\n    navigator))"},
        "format-roman" {:type "defn-",
                        :key "format-roman",
                        :lines [1309 1331],
                        :filename "pprint.cljs",
                        :source "(defn- format-roman\n  \"Format a roman numeral using the specified look-up table\"\n  [table params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (and (number? arg) (> arg 0) (< arg 4000))\n      (let [digits (remainders 10 arg)]\n        (loop [acc []\n               pos (dec (count digits))\n               digits digits]\n          (if (empty? digits)\n            (print (apply str acc))\n            (let [digit (first digits)]\n              (recur (if (= 0 digit)\n                       acc\n                       (conj acc (nth (nth table pos) (dec digit))))\n                     (dec pos)\n                     (next digits))))))\n      (format-integer ; for anything <= 0 or > 3999, we fall back on ~D\n        10\n        {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n        (init-navigator [arg])\n        {:mincol 0, :padchar 0, :commachar 0 :commainterval 0}))\n    navigator))"},
        "float-parts" {:type "defn-",
                       :key "float-parts",
                       :lines [1412 1422],
                       :filename "pprint.cljs",
                       :source "(defn- float-parts\n  \"Take care of leading and trailing zeros in decomposed floats\"\n  [f]\n  (let [[m e] (float-parts-base f)\n        m1 (rtrim m \\0)\n        m2 (ltrim m1 \\0)\n        delta (- (count m1) (count m2))\n        e (if (and (pos? (count e)) (= (nth e 0) \\+)) (subs e 1) e)]\n    (if (empty? m2)\n      [\"0\" 0]\n      [m2 (- (js/parseInt e) delta)])))"},
        "*print-pprint-dispatch*" {:type "defonce",
                                   :key "*print-pprint-dispatch*",
                                   :lines [620 624],
                                   :filename "pprint.cljs",
                                   :source "(defonce ^:dynamic\n ^{:doc \"The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.\"\n   :added \"1.2\"}\n *print-pprint-dispatch* nil)"},
        "check-enumerated-arg" {:type "defn-",
                                :key "check-enumerated-arg",
                                :lines [834 837],
                                :filename "pprint.cljs",
                                :source "(defn- check-enumerated-arg [arg choices]\n  (if-not (choices arg)\n    ;; TODO clean up choices string\n    (throw (js/Error. (str \"Bad argument: \" arg \". It must be one of \" choices)))))"},
        "with-pretty-writer" {:type "defmacro",
                              :key "with-pretty-writer",
                              :lines [9 16],
                              :filename "pprint.clj",
                              :source "(defmacro with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (cljs.core/binding [~'*out* (if new-writer#\n                         (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                         base-writer#)]\n       ~@body\n       (-ppflush ~'*out*))))"},
        "buffer-length" {:type "defn-",
                         :key "buffer-length",
                         :lines [244 248],
                         :filename "pprint.cljs",
                         :source "(defn- buffer-length [l]\n  (let [l (seq l)]\n    (if l\n      (- (:end-pos (last l)) (:start-pos (first l)))\n      0)))"},
        "round-str" {:type "defn-",
                     :key "round-str",
                     :lines [1440 1484],
                     :filename "pprint.cljs",
                     :source "(defn- round-str [m e d w]\n  (if (or d w)\n    (let [len (count m)\n          ;; Every formatted floating point number should include at\n          ;; least one decimal digit and a decimal point.\n          w (if w (max 2 w)\n                  ;;NB: if w doesn't exist, it won't ever be used because d will\n                  ;; satisfy the cond below. cljs gives a compilation warning if\n                  ;; we don't provide a value here.\n                  0)\n          round-pos (cond\n                      ;; If d was given, that forces the rounding\n                      ;; position, regardless of any width that may\n                      ;; have been specified.\n                      d (+ e d 1)\n                      ;; Otherwise w was specified, so pick round-pos\n                      ;; based upon that.\n                      ;; If e>=0, then abs value of number is >= 1.0,\n                      ;; and e+1 is number of decimal digits before the\n                      ;; decimal point when the number is written\n                      ;; without scientific notation. Never round the\n                      ;; number before the decimal point.\n                      (>= e 0) (max (inc e) (dec w))\n                      ;; e < 0, so number abs value < 1.0\n                      :else (+ w e))\n          [m1 e1 round-pos len] (if (= round-pos 0)\n                                  [(str \"0\" m) (inc e) 1 (inc len)]\n                                  [m e round-pos len])]\n      (if round-pos\n        (if (neg? round-pos)\n          [\"0\" 0 false]\n          (if (> len round-pos)\n            (let [round-char (nth m1 round-pos)\n                  result (subs m1 0 round-pos)]\n              (if (>= (char-code round-char) (char-code \\5))\n                (let [round-up-result (inc-s result)\n                      expanded (> (count round-up-result) (count result))]\n                  [(if expanded\n                     (subs round-up-result 0 (dec (count round-up-result)))\n                     round-up-result)\n                   e1 expanded])\n                [result e1 false]))\n            [m e false]))\n        [m e false]))\n    [m e false]))"},
        "set-pprint-dispatch" {:type "defn",
                               :key "set-pprint-dispatch",
                               :lines [825 828],
                               :filename "pprint.cljs",
                               :source "(defn set-pprint-dispatch\n  [function]\n  (set! *print-pprint-dispatch* function)\n  nil)"},
        "*current-length*" {:type "def",
                            :key "*current-length*",
                            :lines [685 685],
                            :filename "pprint.cljs",
                            :source "(def ^:dynamic ^{:private true} *current-length* nil)"},
        "pprint-array" {:type "def",
                        :key "pprint-array",
                        :lines [2849 2849],
                        :filename "pprint.cljs",
                        :source "(def ^{:private true} pprint-array (formatter-out \"~<[~;~@{~w~^, ~:_~}~;]~:>\"))"},
        "check-flags" {:type "defn-",
                       :key "check-flags",
                       :lines [2512 2523],
                       :filename "pprint.cljs",
                       :source "(defn- check-flags [def flags]\n  (let [allowed (:flags def)]\n    (if (and (not (:at allowed)) (:at flags))\n      (format-error (str \"\\\"@\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:at flags) 1)))\n    (if (and (not (:colon allowed)) (:colon flags))\n      (format-error (str \"\\\":\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:colon flags) 1)))\n    (if (and (not (:both allowed)) (:at flags) (:colon flags))\n      (format-error (str \"Cannot combine \\\"@\\\" and \\\":\\\" flags for format directive \\\"\"\n                         (:directive def) \"\\\"\")\n                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))"},
        "format-old-roman" {:type "defn-",
                            :key "format-old-roman",
                            :lines [1333 1334],
                            :filename "pprint.cljs",
                            :source "(defn- format-old-roman [params navigator offsets]\n  (format-roman old-roman-table params navigator offsets))"},
        "*print-circle*" {:type "def",
                          :key "*print-circle*",
                          :lines [647 650],
                          :filename "pprint.cljs",
                          :source "(def ^:dynamic\n^{:private true,\n  :doc \"Mark circular structures (N.B. This is not yet used)\"}\n*print-circle* nil)"},
        "write-buffered-output" {:type "defn-",
                                 :key "write-buffered-output",
                                 :lines [440 445],
                                 :filename "pprint.cljs",
                                 :source "(defn- write-buffered-output [this]\n  (write-line this)\n  (if-let [buf (getf :buffer)]\n    (do\n      (write-tokens this buf true)\n      (setf :buffer []))))"},
        "format-new-roman" {:type "defn-",
                            :key "format-new-roman",
                            :lines [1336 1337],
                            :filename "pprint.cljs",
                            :source "(defn- format-new-roman [params navigator offsets]\n  (format-roman new-roman-table params navigator offsets))"},
        "make-pretty-writer" {:type "defn-",
                              :key "make-pretty-writer",
                              :lines [720 723],
                              :filename "pprint.cljs",
                              :source "(defn- make-pretty-writer\n  \"Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width\"\n  [base-writer right-margin miser-width]\n  (pretty-writer base-writer right-margin miser-width))"},
        "compiled-directive" {:type "defrecord",
                              :key "compiled-directive",
                              :lines [988 989],
                              :filename "pprint.cljs",
                              :source "(defrecord ^{:private true}\n  compiled-directive [func def params offset])"},
        "emit-nl" {:type "defn-",
                   :key "emit-nl",
                   :lines [383 392],
                   :filename "pprint.cljs",
                   :source "(defn- emit-nl [this nl]\n  (-write (getf :base) (pp-newline))\n  (setf :trailing-white-space nil)\n  (let [lb (:logical-block nl)\n        prefix (:per-line-prefix lb)]\n    (if prefix\n      (-write (getf :base) prefix))\n    (let [istr (apply str (repeat (- @(:indent lb) (count prefix)) \\space))]\n      (-write (getf :base) istr))\n    (update-nl-state lb)))"},
        "code-dispatch" {:type "defmulti",
                         :key "code-dispatch",
                         :lines [3209 3213],
                         :filename "pprint.cljs",
                         :source "(defmulti\n  code-dispatch\n  \"The pretty print dispatch function for pretty printing Clojure code.\"\n  {:added \"1.2\" :arglists '[[object]]}\n  type-dispatcher)"},
        "format-ordinal-english" {:type "defn-",
                                  :key "format-ordinal-english",
                                  :lines [1259 1289],
                                  :filename "pprint.cljs",
                                  :source "(defn- format-ordinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zeroth\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs (is this true?)\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal (drop-last parts))\n                head-str (add-english-scales parts-strs 1)\n                tail-str (format-simple-ordinal (last parts))]\n            (print (str (if (neg? arg) \"minus \")\n                        (cond\n                          (and (not (empty? head-str)) (not (empty? tail-str)))\n                          (str head-str \", \" tail-str)\n\n                          (not (empty? head-str)) (str head-str \"th\")\n                          :else tail-str))))\n          (do (format-integer ;for numbers > 10^63, we fall back on ~D\n                10\n                {:mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n                (init-navigator [arg])\n                {:mincol 0, :padchar 0, :commachar 0 :commainterval 0})\n              (let [low-two-digits (rem arg 100)\n                    not-teens (or (< 11 low-two-digits) (> 19 low-two-digits))\n                    low-digit (rem low-two-digits 10)]\n                (print (cond\n                         (and (== low-digit 1) not-teens) \"st\"\n                         (and (== low-digit 2) not-teens) \"nd\"\n                         (and (== low-digit 3) not-teens) \"rd\"\n                         :else \"th\")))))))\n    navigator))"},
        "write" {:type "defn",
                 :key "write",
                 :lines [749 810],
                 :filename "pprint.cljs",
                 :source "(defn write\n  \"Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n\"\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    ;;TODO rewrite this as a macro\n    (binding [cljs.pprint/*print-base* (:base options cljs.pprint/*print-base*)\n              ;;:case             *print-case*,\n              cljs.pprint/*print-circle* (:circle options cljs.pprint/*print-circle*)\n              ;;:escape           *print-escape*\n              ;;:gensym           *print-gensym*\n              cljs.core/*print-length* (:length options cljs.core/*print-length*)\n              cljs.core/*print-level* (:level options cljs.core/*print-level*)\n              cljs.pprint/*print-lines* (:lines options cljs.pprint/*print-lines*)\n              cljs.pprint/*print-miser-width* (:miser-width options cljs.pprint/*print-miser-width*)\n              cljs.pprint/*print-pprint-dispatch* (:dispatch options cljs.pprint/*print-pprint-dispatch*)\n              cljs.pprint/*print-pretty* (:pretty options cljs.pprint/*print-pretty*)\n              cljs.pprint/*print-radix* (:radix options cljs.pprint/*print-radix*)\n              cljs.core/*print-readably* (:readably options cljs.core/*print-readably*)\n              cljs.pprint/*print-right-margin* (:right-margin options cljs.pprint/*print-right-margin*)\n              cljs.pprint/*print-suppress-namespaces* (:suppress-namespaces options cljs.pprint/*print-suppress-namespaces*)]\n      ;;TODO enable printing base\n      #_[bindings (if (or (not (= *print-base* 10)) *print-radix*)\n                  {#'pr pr-with-base}\n                  {})]\n      (binding []\n        (let [sb (StringBuffer.)\n              optval (if (contains? options :stream)\n                       (:stream options)\n                       true)\n              base-writer (if (or (true? optval) (nil? optval))\n                            (StringBufferWriter. sb)\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n                                (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (true? optval)\n            (*print-fn* (str sb)))\n          (if (nil? optval)\n            (str sb)))))))"},
        "miser-nl?" {:type "defn-",
                     :key "miser-nl?",
                     :lines [329 334],
                     :filename "pprint.cljs",
                     :source "(defn- miser-nl? [this lb section]\n  (let [miser-width (get-miser-width this)\n        maxcol (get-max-column (getf :base))]\n    (and miser-width maxcol\n         (>= @(:start-col lb) (- maxcol miser-width))\n         (linear-nl? this lb section))))"},
        "pprint-set" {:type "def",
                      :key "pprint-set",
                      :lines [2873 2873],
                      :filename "pprint.cljs",
                      :source "(def pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))"},
        "translate-param" {:type "defn-",
                           :key "translate-param",
                           :lines [2482 2492],
                           :filename "pprint.cljs",
                           :source "(defn- translate-param\n  \"Translate the string representation of a param to the internalized\n                                      representation\"\n  [[p offset]]\n  [(cond\n     (= (.-length p) 0) nil\n     (and (= (.-length p) 1) (contains? #{\\v \\V} (nth p 0))) :parameter-from-args\n     (and (= (.-length p) 1) (= \\# (nth p 0))) :remaining-arg-count\n     (and (= (.-length p) 2) (= \\' (nth p 0))) (nth p 1)\n     true (js/parseInt p))\n   offset])"},
        "formatter-out" {:type "defmacro",
                         :key "formatter-out",
                         :lines [125 137],
                         :filename "pprint.clj",
                         :source "(defmacro formatter-out\n  \"Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.\"\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (cljs.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (cljs.pprint/init-navigator args#)]\n         (cljs.pprint/execute-format cf# navigator#)))))"},
        "p-write-char" {:type "defn-",
                        :key "p-write-char",
                        :lines [479 489],
                        :filename "pprint.cljs",
                        :source "(defn- p-write-char [this c]\n  (if (= (getf :mode) :writing)\n    (do\n      (write-white-space this)\n      (-write (getf :base) c))\n    (if (= c \\newline)\n      (write-initial-lines this \\newline)\n      (let [oldpos (getf :pos)\n            newpos (inc oldpos)]\n        (setf :pos newpos)\n        (add-to-buffer this (make-buffer-blob (char c) nil oldpos newpos))))))"},
        "write-line" {:type "defn-",
                      :key "write-line",
                      :lines [424 430],
                      :filename "pprint.cljs",
                      :source "(defn- write-line [this]\n  (loop [buffer (getf :buffer)]\n    (setf :buffer (into [] buffer))\n    (if (not (tokens-fit? this buffer))\n      (let [new-buffer (write-token-string this buffer)]\n        (if-not (identical? buffer new-buffer)\n          (recur new-buffer))))))"},
        "get-line" {:type "defn-",
                    :key "get-line",
                    :lines [163 164],
                    :filename "pprint.cljs",
                    :source "(defn- get-line [this]\n  (get-field this :line))"},
        "table-ize" {:type "defn-",
                     :key "table-ize",
                     :lines [711 714],
                     :filename "pprint.cljs",
                     :source "(defn- table-ize [t m]\n  (apply hash-map (mapcat\n                    #(when-let [v (get t (key %))] [v (val %)])\n                    m)))"},
        "add-english-scales" {:type "defn-",
                              :key "add-english-scales",
                              :lines [1197 1218],
                              :filename "pprint.cljs",
                              :source "(defn- add-english-scales\n  \"Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by\"\n  [parts offset]\n  (let [cnt (count parts)]\n    (loop [acc []\n           pos (dec cnt)\n           this (first parts)\n           remainder (next parts)]\n      (if (nil? remainder)\n        (str (apply str (interpose \", \" acc))\n             (if (and (not (empty? this)) (not (empty? acc))) \", \")\n             this\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\n               (str \" \" (nth english-scale-numbers (+ pos offset)))))\n        (recur\n          (if (empty? this)\n            acc\n            (conj acc (str this \" \" (nth english-scale-numbers (+ pos offset)))))\n          (dec pos)\n          (first remainder)\n          (next remainder))))))"},
        "extract-param" {:type "defn-",
                         :key "extract-param",
                         :lines [2465 2477],
                         :filename "pprint.cljs",
                         :source "(defn- extract-param [[s offset saw-comma]]\n  (let [m (js/RegExp. (.-source param-pattern) \"g\")\n        param (.exec m s)]\n    (if param\n      (let [token-str (first param)\n            remainder (subs s (.-lastIndex m))\n            new-offset (+ offset (.-lastIndex m))]\n        (if (not (= \\, (nth remainder 0)))\n          [[token-str offset] [remainder new-offset false]]\n          [[token-str offset] [(subs remainder 1) (inc new-offset) true]]))\n      (if saw-comma\n        (format-error \"Badly formed parameters in format directive\" offset)\n        [nil [s offset]]))))"},
        "pprint-vector" {:type "defn-",
                         :key "pprint-vector",
                         :lines [2839 2847],
                         :filename "pprint.cljs",
                         :source "(defn- pprint-vector [avec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [aseq (seq avec)]\n      (when aseq\n        (write-out (first aseq))\n        (when (next aseq)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))"},
        "separator?" {:type "defn-",
                      :key "separator?",
                      :lines [2580 2580],
                      :filename "pprint.cljs",
                      :source "(defn- separator? [this] (:separator (:bracket-info (:def this))))"},
        "rtrim" {:type "defn-",
                 :key "rtrim",
                 :lines [113 122],
                 :filename "pprint.cljs",
                 :source "(defn- rtrim [s c]\n  \"Trim all instances of c from the end of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s (dec (count s))) c))\n      (loop [n (dec len)]\n        (cond\n          (neg? n) \"\"\n          (not (= (nth s n) c)) (subs s 0 (inc n))\n          true (recur (dec n))))\n      s)))"},
        "get-writer" {:type "defn-",
                      :key "get-writer",
                      :lines [173 174],
                      :filename "pprint.cljs",
                      :source "(defn- get-writer [this]\n  (get-field this :base))"},
        "pprint-ns-reference" {:type "defn-",
                               :key "pprint-ns-reference",
                               :lines [2943 2975],
                               :filename "pprint.cljs",
                               :source "(defn- pprint-ns-reference\n  \"Pretty print a single reference (import, use, etc.) from a namespace decl\"\n  [reference]\n  (if (sequential? reference)\n    (let [[start end] (brackets reference)\n          [keyw & args] reference]\n      (pprint-logical-block :prefix start :suffix end\n        ((formatter-out \"~w~:i\") keyw)\n        (loop [args args]\n          (when (seq args)\n            ((formatter-out \" \"))\n            (let [arg (first args)]\n              (if (sequential? arg)\n                (let [[start end] (brackets arg)]\n                  (pprint-logical-block :prefix start :suffix end\n                    (if (and (= (count arg) 3) (keyword? (second arg)))\n                      (let [[ns kw lis] arg]\n                        ((formatter-out \"~w ~w \") ns kw)\n                        (if (sequential? lis)\n                          ((formatter-out (if (vector? lis)\n                                            \"~<[~;~@{~w~^ ~:_~}~;]~:>\"\n                                            \"~<(~;~@{~w~^ ~:_~}~;)~:>\"))\n                            lis)\n                          (write-out lis)))\n                      (apply (formatter-out \"~w ~:i~@{~w~^ ~:_~}\") arg)))\n                  (when (next args)\n                    ((formatter-out \"~_\"))))\n                (do\n                  (write-out arg)\n                  (when (next args)\n                    ((formatter-out \"~:_\"))))))\n            (recur (next args))))))\n    (write-out reference)))"},
        "pretty-writer" {:type "defn-",
                         :key "pretty-writer",
                         :lines [495 546],
                         :filename "pprint.cljs",
                         :source "(defn- pretty-writer [writer max-columns miser-width]\n  (let [lb (logical-block. nil nil (atom 0) (atom 0) (atom false) (atom false)\n                           nil nil nil nil)\n        ; NOTE: may want to just `specify!` #js { ... fields ... } with the protocols\n        fields (atom {:pretty-writer true\n                      :base (column-writer writer max-columns)\n                      :logical-blocks lb\n                      :sections nil\n                      :mode :writing\n                      :buffer []\n                      :buffer-block lb\n                      :buffer-level 1\n                      :miser-width miser-width\n                      :trailing-white-space nil\n                      :pos 0})]\n    (reify\n\n      IDeref\n      (-deref [_] fields)\n\n      IWriter\n      (-write [this x]\n        (condp = (type x)\n          js/String\n          (let [s0 (write-initial-lines this x)\n                s (string/replace-first s0 #\"\\s+$\" \"\")\n                white-space (subs s0 (count s))\n                mode (getf :mode)]\n            (if (= mode :writing)\n              (do\n                (write-white-space this)\n                (-write (getf :base) s)\n                (setf :trailing-white-space white-space))\n              (let [oldpos (getf :pos)\n                    newpos (+ oldpos (count s0))]\n                (setf :pos newpos)\n                (add-to-buffer this (make-buffer-blob s white-space oldpos newpos)))))\n          js/Number\n          (p-write-char this x)))\n      (-flush [this]\n        (-ppflush this)\n        (-flush (getf :base)))\n\n      IPrettyFlush\n      (-ppflush [this]\n        (if (= (getf :mode) :buffering)\n          (do\n            (write-tokens this (getf :buffer) true)\n            (setf :buffer []))\n          (write-white-space this)))\n\n      )))"},
        "two-forms" {:type "defn-",
                     :key "two-forms",
                     :lines [3163 3168],
                     :filename "pprint.cljs",
                     :source "(defn- two-forms [amap]\n  (into {}\n    (mapcat\n      identity\n      (for [x amap]\n        [x [(symbol (name (first x))) (second x)]]))))"},
        "pprint-ideref" {:type "defn-",
                         :key "pprint-ideref",
                         :lines [2886 2895],
                         :filename "pprint.cljs",
                         :source "(defn- pprint-ideref [o]\n  (let [prefix (str \"#<\" (map-ref-type (.-name (type o)))\n                    \"@\" (goog/getUid o) \": \")]\n    (pprint-logical-block  :prefix prefix :suffix \">\"\n      (pprint-indent :block (-> (count prefix) (- 2) -))\n      (pprint-newline :linear)\n      (write-out\n        (if (and (satisfies? IPending o) (not (-realized? o)))\n          :not-delivered\n          :else @o)))))"},
        "iterate-sublist" {:type "defn-",
                           :key "iterate-sublist",
                           :lines [1731 1752],
                           :filename "pprint.cljs",
                           :source "(defn- iterate-sublist [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause)\n                             (get-format-arg navigator)\n                             [param-clause navigator])\n        [arg-list navigator] (next-arg navigator)\n        args (init-navigator arg-list)]\n    (loop [count 0\n           args args\n           last-pos (int -1)]\n      (if (and (not max-count) (= (:pos args) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (js/Error \"%{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest args))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause args (:base-args params))]\n          (if (= :up-arrow (first iter-result))\n            navigator\n            (recur (inc count) iter-result (:pos args))))))))"},
        "compile-directive" {:type "defn-",
                             :key "compile-directive",
                             :lines [2555 2573],
                             :filename "pprint.cljs",
                             :source "(defn- compile-directive [s offset]\n  (let [[raw-params [rest offset]] (extract-params s offset)\n        [_ [rest offset flags]] (extract-flags rest offset)\n        directive (first rest)\n        def (get directive-table (string/upper-case directive))\n        params (if def (map-params def (map translate-param raw-params) flags offset))]\n    (if (not directive)\n      (format-error \"Format string ended in the middle of a directive\" offset))\n    (if (not def)\n      (format-error (str \"Directive \\\"\" directive \"\\\" is undefined\") offset))\n    [(compiled-directive. ((:generator-fn def) params offset) def params offset)\n     (let [remainder (subs rest 1)\n           offset (inc offset)\n           trim? (and (= \\newline (:directive def))\n                      (not (:colon params)))\n           trim-count (if trim? (prefix-count remainder [\\space \\tab]) 0)\n           remainder (subs remainder trim-count)\n           offset (+ offset trim-count)]\n       [remainder offset])]))"},
        "get-format-arg" {:type "defn-",
                          :key "get-format-arg",
                          :lines [968 973],
                          :filename "pprint.cljs",
                          :source "(defn- get-format-arg [navigator]\n  (let [[raw-format navigator] (next-arg navigator)\n        compiled-format (if (string? raw-format)\n                          (compile-format raw-format)\n                          raw-format)]\n    [compiled-format navigator]))"},
        "pr" {:type "defn-",
              :key "pr",
              :lines [44 45],
              :filename "pprint.cljs",
              :source "(defn- ^:dynamic pr [& more]\n  (-write *out* (apply pr-str more)))"},
        "consume-while" {:type "defn-",
                         :key "consume-while",
                         :lines [94 100],
                         :filename "pprint.cljs",
                         :source "(defn- consume-while [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result continue new-context] (apply func [context])]\n      (if (not continue)\n        [acc context]\n        (recur new-context (conj acc result))))))"},
        "init-cap-writer" {:type "defn-",
                           :key "init-cap-writer",
                           :lines [2020 2053],
                           :filename "pprint.cljs",
                           :source "(defn- init-cap-writer\n  \"Returns a proxy that wraps writer, capitalizing the first word\"\n  [writer]\n  (let [capped (atom false)]\n    (reify\n      IWriter\n      (-flush [_] (-flush writer))\n      (-write\n        ;;no multi-arity\n        #_([^chars cbuf ^Integer off ^Integer len]\n                    (.write writer cbuf off len))\n        [this x]\n        (condp = (type x)\n          js/String\n          (let [s (string/lower-case x)]\n            (if (not @capped)\n              (let [m (.exec (js/RegExp \"\\\\S\" \"g\") s)\n                    offset (and m (.-index m))]\n                (if offset\n                  (do (-write writer\n                              (str (subs s 0 offset)\n                                   (string/upper-case (nth s offset))\n                                   (string/lower-case (subs s (inc offset)))))\n                      (reset! capped true))\n                  (-write writer s)))\n              (-write writer (string/lower-case s))))\n\n          js/Number\n          (let [c (char x)]\n            (if (and (not @capped) (is-letter? c))\n              (do\n                (reset! capped true)\n                (-write writer (string/upper-case c)))\n              (-write writer (string/lower-case c)))))))))"},
        "pprint-code-list" {:type "defn-",
                            :key "pprint-code-list",
                            :lines [3196 3200],
                            :filename "pprint.cljs",
                            :source "(defn- pprint-code-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (if-let [special-form (*code-table* (first alis))]\n      (special-form alis)\n      (pprint-simple-code-list alis))))"},
        "pprint-simple-code-list" {:type "defn-",
                                   :key "pprint-simple-code-list",
                                   :lines [3150 3159],
                                   :filename "pprint.cljs",
                                   :source "(defn- pprint-simple-code-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (print-length-loop [alis (seq alis)]\n      (when alis\n        (write-out (first alis))\n        (when (next alis)\n          (-write *out* \" \")\n          (pprint-newline :linear)\n          (recur (next alis)))))))"},
        "simple-dispatch" {:type "defmulti",
                           :key "simple-dispatch",
                           :lines [2911 2913],
                           :filename "pprint.cljs",
                           :source "(defmulti simple-dispatch\n  \"The pretty print dispatch function for simple data structure format.\"\n  type-dispatcher)"},
        "buffer-blob" {:type "deftype",
                       :key "buffer-blob",
                       :lines [251 251],
                       :filename "pprint.cljs",
                       :source "(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)"},
        "cl-format" {:type "defn",
                     :key "cl-format",
                     :lines [894 929],
                     :filename "pprint.cljs",
                     :source "(defn cl-format\n  \"An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \\\"Common Lisp the\nLanguage, 2nd edition\\\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n  {:see-also [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\"\n               \"Common Lisp the Language\"]\n              [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n               \"Common Lisp HyperSpec\"]]}\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))"},
        "end-block-t" {:type "deftype",
                       :key "end-block-t",
                       :lines [258 258],
                       :filename "pprint.cljs",
                       :source "(deftype end-block-t :logical-block :start-pos :end-pos)"},
        "print-char" {:type "defn-",
                      :key "print-char",
                      :lines [33 42],
                      :filename "pprint.cljs",
                      :source "(defn- print-char [c]\n  (-write *out* (condp = c\n                  \\backspace \"\\\\backspace\"\n                  \\tab \"\\\\tab\"\n                  \\newline \"\\\\newline\"\n                  \\formfeed \"\\\\formfeed\"\n                  \\return \"\\\\return\"\n                  \\\" \"\\\\\\\"\"\n                  \\\\ \"\\\\\\\\\"\n                  (str \"\\\\\" c))))"},
        "insert-decimal" {:type "defn-",
                          :key "insert-decimal",
                          :lines [1496 1502],
                          :filename "pprint.cljs",
                          :source "(defn- insert-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m e]\n  (if (neg? e)\n    (str \".\" m)\n    (let [loc (inc e)]\n      (str (subs m 0 loc) \".\" (subs m loc)))))"},
        "tokens-fit?" {:type "defn-",
                       :key "tokens-fit?",
                       :lines [319 323],
                       :filename "pprint.cljs",
                       :source "(defn- tokens-fit? [this tokens]\n  (let [maxcol (get-max-column (getf :base))]\n    (or\n      (nil? maxcol)\n      (< (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))"},
        "collect-clauses" {:type "defn-",
                           :key "collect-clauses",
                           :lines [2621 2668],
                           :filename "pprint.cljs",
                           :source "(defn- collect-clauses [bracket-info offset remainder]\n  (second\n    (consume\n      (fn [[clause-map saw-else remainder]]\n        (let [[clause [type right-params else-params remainder]]\n              (process-clause bracket-info offset remainder)]\n          (cond\n            (= type :right-bracket)\n            [nil [(merge-with concat clause-map\n                              {(if saw-else :else :clauses) [clause]\n                               :right-params right-params})\n                  remainder]]\n\n            (= type :else)\n            (cond\n              (:else clause-map)\n              (format-error \"Two else clauses (\\\"~:;\\\") inside bracket construction.\" offset)\n\n              (not (:else bracket-info))\n              (format-error \"An else clause (\\\"~:;\\\") is in a bracket type that doesn't support it.\"\n                            offset)\n\n              (and (= :first (:else bracket-info)) (seq (:clauses clause-map)))\n              (format-error\n                \"The else clause (\\\"~:;\\\") is only allowed in the first position for this directive.\"\n                offset)\n\n              true         ; if the ~:; is in the last position, the else clause\n              ; is next, this was a regular clause\n              (if (= :first (:else bracket-info))\n                [true [(merge-with concat clause-map {:else [clause] :else-params else-params})\n                       false remainder]]\n                [true [(merge-with concat clause-map {:clauses [clause]})\n                       true remainder]]))\n\n            (= type :separator)\n            (cond\n              saw-else\n              (format-error \"A plain clause (with \\\"~;\\\") follows an else clause (\\\"~:;\\\") inside bracket construction.\" offset)\n\n              (not (:allows-separator bracket-info))\n              (format-error \"A separator (\\\"~;\\\") is in a bracket type that doesn't support it.\"\n                            offset)\n\n              true\n              [true [(merge-with concat clause-map {:clauses [clause]})\n                     false remainder]]))))\n      [{:clauses []} false remainder])))"},
        "right-bracket" {:type "defn-",
                         :key "right-bracket",
                         :lines [2578 2578],
                         :filename "pprint.cljs",
                         :source "(defn- right-bracket [this] (:right (:bracket-info (:def this))))"},
        "upcase-writer" {:type "defn-",
                         :key "upcase-writer",
                         :lines [1938 1957],
                         :filename "pprint.cljs",
                         :source "(defn- upcase-writer\n  \"Returns a proxy that wraps writer, converting all characters to upper case\"\n  [writer]\n  (reify\n    IWriter\n    (-flush [_] (-flush writer))\n    (-write\n      ;;no multi-arity, not sure of importance\n      #_([^chars cbuf ^Integer off ^Integer len]\n             (.write writer cbuf off len))\n      [this x]\n      (condp = (type x)\n        js/String\n        (let [s x]\n          (-write writer (string/upper-case s)))\n\n        js/Number\n        (let [c x]\n          ;;TODO need to enforce integers only?\n          (-write writer (string/upper-case (char c))))))))"},
        "deftype" {:type "defmacro",
                   :key "deftype",
                   :lines [31 40],
                   :filename "pprint.clj",
                   :source "(defmacro deftype\n  [type-name & fields]\n  (let [name-str (name type-name)\n        fields (map (comp symbol name) fields)]\n    `(do\n       (defrecord ~type-name [~'type-tag ~@fields])\n       (defn- ~(symbol (str \"make-\" name-str))\n         ~(vec fields)\n         (~(symbol (str type-name \".\")) ~(keyword name-str) ~@fields))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))"},
        "next-arg-or-nil" {:type "defn-",
                           :key "next-arg-or-nil",
                           :lines [961 965],
                           :filename "pprint.cljs",
                           :source "(defn- next-arg-or-nil [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (arg-navigator. (:seq navigator) (next rst) (inc (:pos navigator)))]\n      [nil navigator])))"}}}
